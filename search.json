[{"title":"Ajax","url":"/2021/12/10/Ajax/","content":"Ajax实现即时请求并且不改变url地址Demo\n新建项目，配置web.xml\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;         version=&quot;4.0&quot;&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;    &lt;filter&gt;        &lt;filter-name&gt;encoding&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;encoding&lt;/param-name&gt;            &lt;param-value&gt;utf-8&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;encoding&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;&lt;/web-app&gt;\n\n\n新建springmvc核心配置文件并配置\n\n```xml\n\n&lt;beans xmlns=”http://www.springframework.org/schema/beans&quot;\n   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n   xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n   xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;\n   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans.xsd\n    http://www.springframework.org/schema/context\n    http://www.springframework.org/schema/context/spring-context.xsd\n    http://www.springframework.org/schema/mvc\n    http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;\n\n\n\n&lt;!--    必须加这句--&gt;\n&lt;mvc:default-servlet-handler/&gt;\n&lt;!--    开启注解支持--&gt;\n&lt;mvc:annotation-driven/&gt;\n&lt;!--设置自动扫描包，让指定包下的注解生效，由IOC容器统一管理--&gt;\n&lt;context:component-scan base-package=&quot;com.wx.controller&quot;/&gt;\n\n&lt;!--    配置视图解析器，用来解析controller传来的ModelAndView对象--&gt;\n&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt;\n    &lt;!--        前缀--&gt;\n    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;\n    &lt;!--        后缀--&gt;\n    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;\n&lt;/bean&gt;\n\n\n3. 导入相关依赖```xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;parent&gt;        &lt;artifactId&gt;SpringMvc&lt;/artifactId&gt;        &lt;groupId&gt;org.example&lt;/groupId&gt;        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;/parent&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;artifactId&gt;springmvc_04_ajax&lt;/artifactId&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;            &lt;version&gt;2.5&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;            &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;            &lt;version&gt;2.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;jstl&lt;/artifactId&gt;            &lt;version&gt;1.2&lt;/version&gt;        &lt;/dependency&gt;&lt;!--        添加jackson依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;            &lt;version&gt;2.11.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;            &lt;version&gt;2.11.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;            &lt;version&gt;2.11.0&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;\n编写controller\n\n\npackage com.wx.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.servlet.http.HttpServletResponse;import javax.xml.ws.Response;import java.io.IOException;@RestControllerpublic class AjaxController &#123;    @RequestMapping(&quot;/t1&quot;)    public String test()&#123;        return &quot;sucess&quot;;    &#125;    @RequestMapping(&quot;/a1&quot;)    public void a1(String name, HttpServletResponse response) throws IOException &#123;        System.out.println(name);        if(&quot;zhangsan&quot;.equals(name))&#123;            response.getWriter().print(&quot;same&quot;);        &#125;else &#123;            response.getWriter().println(&quot;different&quot;);        &#125;    &#125;&#125;\n\n\n引入JQuery\n\n\n\n编写jsp页面\n\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;  &lt;head&gt;    &lt;title&gt;$Title$&lt;/title&gt;    &lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.6.0.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;      function a()&#123;        $.ajax(&#123;          url: &quot;$&#123;pageContext.request.contextPath&#125;/a1&quot;,          type: &quot;post&quot;,          data: &#123;&quot;name&quot; : $(&quot;#username&quot;).val()&#125;,          success: function (d) &#123;              console.log(&quot;data&quot;,this.data);              console.log(&quot;前端接收到的&quot;,d);          &#125;        &#125;)      &#125;    &lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;  &lt;input type=&quot;text&quot; id=&quot;username&quot; onblur=&quot;a()&quot;&gt;  &lt;/body&gt;&lt;/html&gt;\n\n\n测试：\nhttp://localhost:8080/，文本框输入不同字符并失去焦点后-&gt;\n\n\n模拟Ajax传递对象新建pojo类\npackage com.wx.pojo;public class Person &#123;    int age;    String name;    String sex;    public Person(int age, String name, String sex) &#123;        this.age = age;        this.name = name;        this.sex = sex;    &#125;    public Person() &#123;    &#125;    public int getAge() &#123;        return age;    &#125;    public String getName() &#123;        return name;    &#125;    public String getSex() &#123;        return sex;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public void setSex(String sex) &#123;        this.sex = sex;    &#125;    @Override    public String toString() &#123;        return &quot;Person&#123;&quot; +                &quot;age=&quot; + age +                &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, sex=&#x27;&quot; + sex + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;\n\ncontroller类\npackage com.wx.controller;import com.wx.pojo.Person;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.bind.annotation.RestController;import javax.servlet.http.HttpServletResponse;import javax.xml.ws.Response;import java.io.IOException;import java.util.ArrayList;import java.util.List;@RestControllerpublic class AjaxController &#123;      @RequestMapping(&quot;/a2&quot;)    public List&lt;Person&gt; a2()&#123;        List&lt;Person&gt; list = new ArrayList&lt;Person&gt;();        //添加数据        list.add(new Person(12,&quot;张三&quot;,&quot;男&quot;));        list.add(new Person(11,&quot;张三&quot;,&quot;男&quot;));        list.add(new Person(10,&quot;张三&quot;,&quot;男&quot;));        return list;    &#125;&#125;\n\n请求a2获取后端返回对象\n\nDemo: 输入账号密码实时判断package com.wx.controller;import com.wx.pojo.Person;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.bind.annotation.RestController;import javax.servlet.http.HttpServletResponse;import javax.xml.ws.Response;import java.io.IOException;import java.util.ArrayList;import java.util.List;@RestControllerpublic class AjaxController &#123;     @RequestMapping(&quot;/a3&quot;)    public String judge(String userName,String passWord)&#123;        String msg = &quot;&quot;;        if (userName != null)&#123;            if(&quot;admin&quot;.equals(userName))&#123;                msg = &quot;ok&quot;;            &#125;else &#123;                msg = &quot;用户名有误&quot;;            &#125;        &#125;        if (passWord != null)&#123;            if(&quot;123456&quot;.equals(passWord))&#123;                msg = &quot;ok&quot;;            &#125;else &#123;                msg = &quot;密码有误&quot;;            &#125;        &#125;        return msg;    &#125;&#125;\n\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.6.0.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        //方式一：        $(function () &#123;            $(&quot;#name&quot;).blur(function () &#123;                $.ajax(&#123;                        url: &quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;,                        type: &quot;post&quot;,                        data: &#123;&quot;userName&quot;: $(&quot;#name&quot;).val()&#125;,                        success: function (data) &#123;                            console.log(&quot;name数据&quot;,data)                            if (data.toString() === &quot;ok&quot;)&#123;                                $(&quot;#span1&quot;).html(&quot;ok&quot;)                                $(&quot;#span1&quot;).css(&quot;color&quot;,&quot;green&quot;);                            &#125; else &#123;                                $(&quot;#span1&quot;).html(&quot;用户名错误&quot;)                                $(&quot;#span1&quot;).css(&quot;color&quot;,&quot;red&quot;);                            &#125;                        &#125;,                        error: function(data) &#123;                            console.log(data)                        &#125;                    &#125;)            &#125;)        &#125;)        // 方式二        function request2() &#123;            $.post(&#123;                url: &quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;,                data: &#123;&quot;passWord&quot;: $(&quot;#pwd&quot;).val()&#125;,                success: function (data) &#123;                    console.log(&quot;pwd数据&quot;,data)                    if (data.toString() === &quot;ok&quot;)&#123;                        $(&quot;#span2&quot;).html(&quot;ok&quot;)                        $(&quot;#span2&quot;).css(&quot;color&quot;,&quot;green&quot;);                    &#125; else &#123;                        $(&quot;#span2&quot;).html(&quot;密码错误&quot;)                        $(&quot;#span2&quot;).css(&quot;color&quot;,&quot;red&quot;);                    &#125;                &#125;,                error: function(data) &#123;                    console.log(data)                &#125;            &#125;)        &#125;    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;    用户名:&lt;input type=&quot;text&quot; id=&quot;name&quot;&gt;    &lt;span id=&quot;span1&quot;&gt;&lt;/span&gt;&lt;/br&gt;&lt;/p&gt;&lt;p&gt;    密码:&lt;input type=&quot;text&quot; id=&quot;pwd&quot; onblur=&quot;request2()&quot;&gt;    &lt;span id=&quot;span2&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\n\n结果:\n\n\nemmm，写demo的时候因为一个疏忽耽误了一晚上….现象为ajax请求成功，状态200，但是返回为空，打印的语句也不输出，成功/失败的回调函数都不执行，最后发现是ajax请求的data参数名写错…大小写没注意，userName写成username…引以为戒\n","tags":["Ajax"]},{"title":"RestFul","url":"/2021/12/07/RestFul/","content":"RestFul风格及SpringMVC前后端数据传递RestFulRestFul是一个资源定位及资源操作的风格，不是标准也不是协议，只是一种资源定位风格，基于RestFul风格设计的程序更易于实现缓存机制—–待验证哈哈哈哈哈，更简洁有层次\n1、非RestFul(具体见SpringMVC_03_anno)package com.wx.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class RestFulController &#123;    @RequestMapping(&quot;/add&quot;)    public String test(int a,int b,Model model)&#123;        int res = a + b;        model.addAttribute(&quot;msg&quot;,&quot;和为：&quot;+ res);        return &quot;hello&quot;;    &#125;&#125;\n\n结果:\n2、RestFul风格在RequestMapping上加入路径变量，让方法参数的值绑定到对应URI模板变量之上\npackage com.wx.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class RestFulController &#123;    @RequestMapping(&quot;/add/&#123;a&#125;/&#123;b&#125;&quot;)  //等价于@RequestMapping(value(或者path)=&quot;/add/&#123;a&#125;/&#123;b&#125;&quot;,method=RequestMethod.GET)  //等价于@GetMapping(&quot;/add/&#123;a&#125;/&#123;b&#125;&quot;)    public String test(@PathVariable int a,@PathVariable int b, Model model)&#123;        int res = a + b;        model.addAttribute(&quot;msg&quot;,&quot;和为：&quot;+ res);        return &quot;hello&quot;;    &#125;&#125;\n\n\n前后端数据传递前端 ———&gt; 后端1、提交的域名称与controller方法的参数名一致提交：http://localhost:8080/add?a=1&amp;b=2\ncontroller处理方法:\n@Controllerpublic class RestFulController &#123;      @RequestMapping(&quot;/add&quot;)      public String test(int a,int b,Model model)&#123;            int res = a + b;            model.addAttribute(&quot;msg&quot;,&quot;和为：&quot;+ res);            return &quot;hello&quot;;      &#125;&#125;\n\n\n\n2、提交的域名称与Controller方法的参数名不一致此时需要@RequestParam(param)注解来对应请求中的参数名,这里的param代表的是请求中的参数，此注解应加在对应方法参数上\n提交：http://localhost:8080/add?a=1&amp;b=2\n@Controllerpublic class RestFulController &#123;      @RequestMapping(&quot;/add&quot;)      public String test(@RequestParam(a) int param1,@RequestParam(b) int param2,Model model)&#123;            int res = param1 + param2;            model.addAttribute(&quot;msg&quot;,&quot;和为：&quot;+ res);            return &quot;hello&quot;;      &#125;&#125;\n\n3、前端传递的为对象(即传递的为多个参数)只需要保证提交的表单域与后端对象的属性名保持一致则Controller方法接收的参数可以直接使用对象\npackage com.wx.pojo;//前端多个参数所对应的后端pojo对象public class Person &#123;    int age;    String name;    String sex;    public void setAge(int age) &#123;        this.age = age;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public void setSex(String sex) &#123;        this.sex = sex;    &#125;    @Override    public String toString() &#123;        return &quot;Person&#123;&quot; +                &quot;age=&quot; + age +                &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, sex=&#x27;&quot; + sex + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;//Controller接收参数直接使用pojo对象 @RequestMapping(&quot;/user&quot;)    public String userTest(Person person, Model model)&#123;        System.out.println(person);        model.addAttribute(&quot;msg&quot;,&quot;接收参数为：&quot;+ person);        return &quot;hello&quot;;    &#125;\n\n注意：\n\n如果使用第三种方式则必须保证传递的各个参数与pojo对象各个属性名保持一致\n第三种方式pojo类必须有set方法\n\n1、接收前端用户传递的参数，会先判断参数的名字，如果名字在方法上直接能找到则直接匹配传递\n2、假设传递的是一个对象Person，则匹配Person对象中的各个属性名，如果有不一致则匹配不到，只能拿到null\n后端 ———–&gt;前端1、通过ModelAndView的方式传递package com.wx.controller;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class HelloController implements Controller &#123;    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;       //ModelAndView  这个就是处理后返回的模型视图对象        ModelAndView mv = new ModelAndView();        //封装对象并且放在ModelAndView中        mv.addObject(&quot;msg&quot;,&quot;这就是要传递到前端的参数啦&quot;);        //封装要跳转的视图  /WEB-INF/jsp/hello.jsp        mv.setViewName(&quot;hello&quot;);        return mv;    &#125;&#125;\n\n2、通过Model(继承自ModalMap)传递package com.wx.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class RestFulController &#123;    @RequestMapping(&quot;/add&quot;)    public String test(Model model)&#123;      //相当于servlet中的req.setAttribute(&quot;msg&quot;,&quot;这就是要传递到前端的参数啦&quot;)        model.addAttribute(&quot;msg&quot;,&quot;这就是要传递到前端的参数啦&quot;);        return &quot;hello&quot;;    &#125;&#125;\n\n3、通过ModalMap传递(继承自LinkedHashMap，具有其全部的功能)package com.wx.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class RestFulController &#123;    @RequestMapping(&quot;/add&quot;)    public String test(ModalMap modelMap)&#123;      //相当于servlet中的req.setAttribute(&quot;msg&quot;,&quot;这就是要传递到前端的参数啦&quot;)        modelMap.addAttribute(&quot;msg&quot;,&quot;这就是要传递到前端的参数啦&quot;);        return &quot;hello&quot;;    &#125;&#125;\n\n几个方式的对比\n\nModelMap继承自LinkedHashMap，除了自身的方法外继承了LinkedMap的特性\nModel继承自ModelMap，相当于精简版的ModelMap\nModelAndView可以在存储数据的同时，可以设置返回的逻辑视图，控制展示层的跳转\n\n","categories":["数据传递"],"tags":["RestFul"]},{"title":"Spring MVC","url":"/2021/12/02/Spring-MVC/","content":"Spring  MVC1、回顾servlet\n编写一个普通的类继承servlet接口，重写doGet()和doPost()方法\n在web.xml中配置servlet\n\nseevlet-Demo1.导入servlet依赖&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;parent&gt;        &lt;artifactId&gt;SpringMvc&lt;/artifactId&gt;        &lt;groupId&gt;org.example&lt;/groupId&gt;        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;/parent&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;artifactId&gt;springmvc_01_servlet&lt;/artifactId&gt;&lt;!--    导入依赖--&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;            &lt;version&gt;2.5&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;            &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;            &lt;version&gt;2.2&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;\n\n2.编写servlet类，继承httpservlet类，重写doGet()和doPost()方法import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class HelloServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //1.获取前端参数        String method = req.getParameter(&quot;method&quot;);        if(method.equals(&quot;add&quot;))&#123;            req.getSession().setAttribute(&quot;msg&quot;,&quot;执行了add方法&quot;);        &#125;        if(method.equals(&quot;delete&quot;))&#123;            req.getSession().setAttribute(&quot;msg&quot;,&quot;执行了delete方法&quot;);        &#125;      //2.调用业务逻辑      //3.视图转发或者重定向    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        doGet(req,resp);    &#125;&#125;\n\n3.编写视图层前端页面&lt;!--  请求页  --&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;登录页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/hello&quot;&gt;    &lt;input type=&quot;text&quot; name=&quot;method&quot;&gt;    &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;!--  视图转发页面  --&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt;\n\n4.配置servlet配置文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;         version=&quot;4.0&quot;&gt;    &lt;!--    配置servlet，依靠servlet-name配对，   servlet-class定位servlet类(java文件夹下即为根路径)，   url-pattern配置请求路径--&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;        &lt;servlet-class&gt;HelloServlet&lt;/servlet-class&gt;    &lt;/servlet&gt;        &lt;servlet-mapping&gt;        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;        &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;    &lt;!--    配置请求超时时间--&gt;    &lt;session-config&gt;        &lt;session-timeout&gt;15&lt;/session-timeout&gt;    &lt;/session-config&gt;&lt;!--    设置欢迎页--&gt;    &lt;welcome-file-list&gt;        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;    &lt;/welcome-file-list&gt;    &lt;/web-app&gt;\n\n5.发送请求验证\nhttp://localhost:8080/hello?method=add\nhttp://localhost:8080/hello?method=delete\n\n2、SpringMVC执行原理发起请求时被前端控制器DespatcherServlet拦截请求，根据请求参数生成代理请求，找到请求对应的实际控制器，将请求发送给对应的servlet控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给servlet控制器，servlet控制器根据模型与视图渲染出视图，再将视图(ModelAndView)返回给前端控制器DespatcherServlet，最后用户收到返回的结果。\n\n相较于传统MVC模型，SpringMVC多了一个DespatcherServlet前端控制器，起到处理，分发请求的作用\n3、第一个SpringMVC-Demo\n新建moudle，添加frameweb支持\n导入SpringMVC依赖\n\n&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;            &lt;version&gt;2.5&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;            &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;            &lt;version&gt;2.2&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;\n\n\n\n\n配置web.XML，注册DispatcherServlet\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;         version=&quot;4.0&quot;&gt;&lt;!--    注册dispatcherservlet--&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;!--        这个servlet需要关联一个springmvc的配置文件(servletName-servlet.xml)--&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/servlet&gt;    &lt;!--    /匹配所有的请求但不包括.jsp--&gt;    &lt;!--    /*匹配所有的请求且包括.jsp--&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;\n\n\n\n\n添加springmvc默认配置文件spring-servlet.xml\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;!--    配置spring的请求处理器和映射器，固定写法必须导入--&gt;    &lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;    &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt;&lt;!--    配置视图解析器，用来解析controller传来的ModelAndView对象--&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt;&lt;!--        前缀--&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;&lt;!--        后缀--&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;    &lt;/bean&gt;&lt;!--    将bean交由spring容器管理--&gt;    &lt;bean id=&quot;/hello&quot; class=&quot;com.wx.controller.HelloController&quot;/&gt;&lt;/beans&gt;\n\n\n编写controll类实现controller接口\n\npackage com.wx.controller;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class HelloController implements Controller &#123;    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;       //ModelAndView  这个就是处理后返回的数据模型        ModelAndView mv = new ModelAndView();        //封装对象并且放在ModelAndView中        mv.addObject(&quot;msg&quot;,&quot;HelloSpringMVC&quot;);        //封装要跳转的视图  /WEB-INF/jsp/hello.jsp        mv.setViewName(&quot;hello&quot;);        return mv;    &#125;&#125;\n\n注意：\n\nspring-servlet.xml中注入的bean_id前面需要加上“/”否则可能会404\n如果项目代码无误出现404或者500，需要到项目结构中找到项目打的包，并在WEB-INF目录下添加lib文件夹，加入所有依赖\nSpringMVC自身命名为servlet名-servlet.xml\n\n\n4、annotation注解实现\n引入springmvc依赖\n加入web支持，配置web.xml(注册DispatcherServlet,关联SpringMVC配置文件，设置启动级别为1—–项目启动时自启动，设置映射路径为/)\n编写springmvc-servlet.xml配置文件\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    &lt;!--    让mvc支持注解驱动--&gt;    &lt;mvc:default-servlet-handler/&gt;    &lt;!--    开启注解支持--&gt;    &lt;mvc:annotation-driven/&gt;    &lt;!--设置自动扫描包，让指定包下的注解生效，由IOC容器统一管理--&gt;    &lt;context:component-scan base-package=&quot;com.wx.controller&quot;/&gt;    &lt;!--    配置视图解析器，用来解析controller传来的ModelAndView对象--&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt;        &lt;!--        前缀--&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;        &lt;!--        后缀--&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n\n编写web.xml配置文件,注册DispatcherServlet\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;         version=&quot;4.0&quot;&gt;    &lt;!--    注册dispatcherservlet--&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;!--        这个servlet需要关联一个springmvc的配置文件(servletName-servlet.xml)--&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;!--        设置启动顺序，数字越小启动越早--&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;!--    /匹配所有的请求但不包括.jsp--&gt;    &lt;!--    /*匹配所有的请求且包括.jsp--&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;\n\n\n编写对应的controller类\n\npackage com.wx.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class HelloController &#123;   @RequestMapping(&quot;/h1&quot;)    public String hello(Model model)&#123;        //封装数据        model.addAttribute(&quot;msg&quot;,&quot;这是hello1请求的数据&quot;);        //被视图解析器解析，拼接成正确的跳转路径        return &quot;hello&quot;;    &#125;    @RequestMapping(&quot;/h2&quot;)    public String hellos(Model model)&#123;        //封装数据        model.addAttribute(&quot;msg&quot;,&quot;这是hello2请求的数据&quot;);        //被视图解析器解析，拼接成正确的跳转路径        return &quot;hello&quot;;    &#125;&#125;\n\n\n编写对应的jsp文件\n\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt;\n\nemmmm,遇到一个错误排查了一天，终于在晚上临睡前找到原因了…检查了代码编写的没问题，项目结构里打包的artifacts里面该有的包也有了，最后发现是项目的web文件夹和别的web项目长得不太一样…不知道干了啥导致idea不能识别本项目的web文件夹了，解决办法:\n![屏幕截图 2021-12-07 001916](../images/Spring-MVC/屏幕截图 2021-12-07 001916.png)\n","categories":["SpringMVC"],"tags":["SpringMVC"]},{"title":"Vue","url":"/2021/12/01/Vue/","content":"Vue语法//导入vue.js &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt;//使用vue指令必须导入命名空间v-bind=&quot;http://www.w3.org/1999/xhtml\n\n基础指令合集v-bind、v-if、v-else、v-for&lt;!--vue层  模板--&gt;&lt;div id=&quot;app&quot;&gt;&lt;!--    v-bind指令  用于将标签的某个属性和vue对象的某个属性绑定--&gt;    &lt;span v-bind:title=&quot;message&quot;&gt;&lt;!--            v-if指令，v-else指令--&gt;        &lt;h1 v-if=&quot;ok===true&quot;&gt;Yes&lt;/h1&gt;        &lt;h1 v-else&gt;No&lt;/h1&gt;    &lt;/span&gt;&lt;!--    v-for指令--&gt;    &lt;li v-for=&quot;item in items&quot;&gt;        &#123;&#123;item.messages&#125;&#125;    &lt;/li&gt;&lt;/div&gt;&lt;div id = &quot;func&quot;&gt;    &lt;button v-on:click=&quot;sayHi&quot;&gt;点击事件测试&lt;/button&gt;&lt;/div&gt;&lt;body&gt;&lt;script&gt;    // 创建vue对象    var vm = new Vue(&#123;         el:&quot;#app&quot;,//el即组件        // model 数据        data:&#123;            message:&quot;hello,vue!&quot;,            ok:true,            items:[                &#123;messages:&#x27;java&#x27; &#125;,                &#123;messages:&#x27;vue&#x27;&#125;,                &#123;messagea:&#x27;html&#x27; &#125;            ]        &#125;    &#125;);    var vs = new Vue(&#123;        el:func,        date:&#123;            message:&quot;vue方法绑定&quot;        &#125;,        methods:&#123;            //这里的事件必须在vue的对象中定义            sayHi:function () &#123;                alert(this.message);            &#125;        &#125;    &#125;)&lt;/script&gt;\n\n组件即可复用的Vue实例，就是一组可以重复使用的模板，跟JSTL的自定义标签，Thymeleaf的th:fragment等框架类似。\n//定义一个vue组件Vue.component(&quot;component_Name&quot;,&#123;  template:&quot;一段html模板&quot;&#125;);\n\n实例代码：\n&lt;body&gt;&lt;div id = &quot;app&quot;&gt;    &lt;wangxu&gt;&lt;/wangxu&gt;&lt;/div&gt;//组件中如果想接收外部传递的数据必须使用props属性来接收,并且也无法直接从其他组件或者vue对象中获取数据，需要通过中间件来动态绑定数据，即此处的  v-bind:dat=&quot;item&quot;&lt;div id = &quot;app2&quot;&gt;    &lt;vslist v-for=&quot;item in items&quot; v-bind:dat=&quot;item&quot;&gt;&lt;/vslist&gt;&lt;/div&gt;&lt;script&gt;    //定义一个Vue的组件Component    Vue.component(&quot;wangxu&quot;,&#123;        template:&#x27;&lt;div&gt;&lt;li&gt;ahahahah&lt;/li&gt;&#x27; +            &#x27;&lt;li&gt;sssss&lt;/li&gt;&lt;/div&gt;&#x27;    &#125;);    var vm = new Vue(&#123;        el:&quot;#app&quot;    &#125;);    Vue.component(&quot;vslist&quot;,&#123;        props:[&#x27;dat&#x27;],        template:&#x27;&lt;li&gt;&#123;&#123;dat&#125;&#125;&lt;/li&gt;&#x27;    &#125;)    var vm2 = new Vue(&#123;        el:&quot;#app2&quot;,        data:&#123;            items:[&#x27;java&#x27;,&#x27;linux&#x27;,&#x27;web&#x27;]        &#125;    &#125;)&lt;/script&gt;&lt;/body&gt;\n\nAxiosaxios是一个开源的可以用在浏览器端和NodeJS的异步通信框架，主要作用就是实现AJAX异步通信，功能特点如下：\n\n从浏览器中创建XMLHttpRequests\n从node.js创建http请求\n支持JS中链式变成\n拦截请求和响应\n转换请求数据和响应数据\n取消请求\n自动转换json数据\n客户端支持防御跨站请求伪造\n\n&lt;body&gt;&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt;&lt;div id = &quot;vue&quot; v-clock&gt;    &lt;div&gt;&#123;&#123;info.name&#125;&#125;&lt;/div&gt;    &lt;div&gt;&#123;&#123;info.address.city&#125;&#125;&lt;/div&gt;    &lt;a v-bind:href=&quot;info.url&quot;&gt;点击跳转&lt;/a&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var vm = new Vue(&#123;        el:&#x27;#vue&#x27;,        data()&#123;            //data()方法通过return来接收mounted（）返回的数据              return&#123;                  //请求的返回参数格式必须和json字符串一样                  info:&#123;                      name:null,                      address:&#123;                          city:null,                          country:null                      &#125;,                      url:null                  &#125;              &#125;        &#125;,        //Vue专注于视图层，数据交互叫交付于axios        mounted()&#123;//钩子函数 链式编程 ES6新特性            axios.get(&#x27;data.json&#x27;).then(response=&gt;(console.log(this.info=response.data)));        &#125;    &#125;);&lt;/script&gt;&lt;/body&gt;\n\n计算属性//在调用方法时，每次都需要进行计算，但是计算过程会有系统开销，如果这个这个计算结果不是经常变化的，就可以考虑把结果缓存起来，采用计算属性可以很方便的做到这一点，计算属性的主要特性就是为了将不经常变化的计算结果进行缓存以节约系统开销。&lt;body&gt;&lt;div id = &quot;app&quot;&gt;    &lt;p&gt;current_time&#123;&#123;current_time()&#125;&#125;&lt;/p&gt;    &lt;p&gt;current_time2&#123;&#123;current_time2&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt;    var vm = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            message:&quot;hello,wangxu&quot;        &#125;,        methods:&#123;            current_time:function()&#123;                return Date.now();//返回一个时间戳            &#125;        &#125;,        computed:&#123;//计算属性,类似于mybatis中缓存的概念，这里是虚拟dom，一但计算属性中涉及到数据更改，就立刻刷新dom重新计算            current_time2:function()&#123;                this.message;                return Date.now();            &#125;        &#125;    &#125;)&lt;/script&gt;\n\n内容分发使用这一种方式混合父组件与子组件自己的模板，这个过程被称为“内容分发”，在子组件中使用的特殊的元素作为容器的插槽\n&lt;body&gt;&lt;div id = &quot;app&quot;&gt;    &lt;todo&gt;        &lt;todo-title slot=&quot;todo-title&quot; v-bind:title = &quot;title&quot;&gt;&lt;/todo-title&gt;        &lt;todo-items slot=&quot;todo-items&quot; v-for=&quot;item in todoItems&quot; :item = &quot;item&quot;&gt;&lt;/todo-items&gt;    &lt;/todo&gt;&lt;/div&gt;&lt;!--即不是用插槽是以下样式--&gt;&lt;!--&lt;div&gt;--&gt;&lt;!--    &lt;title&gt;&lt;/title&gt;--&gt;&lt;!--    &lt;ul&gt;--&gt;&lt;!--        &lt;li&gt;java&lt;/li&gt;--&gt;&lt;!--        &lt;li&gt;linux&lt;/li&gt;--&gt;、&lt;!--        &lt;li&gt;web&lt;/li&gt;--&gt;&lt;!--    &lt;/ul&gt;--&gt;&lt;!--&lt;/div&gt;--&gt;&lt;script&gt;    //slot插槽    Vue.component(&quot;todo&quot;,&#123;        template:&#x27;&lt;div&gt;\\                        &lt;slot name=&quot;todo-title&quot;&gt;&lt;/slot&gt;\\                        &lt;ul&gt;\\                        &lt;slot name=&quot;todo-items&quot;&gt;&lt;/slot&gt;\\                        &lt;/ul&gt;\\                        &lt;/div&gt;&#x27;    &#125;);    Vue.component(&quot;todo-title&quot;,&#123;        props: [&#x27;title&#x27;],        template:&#x27;&lt;div&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;&#x27;    &#125;);    Vue.component(&quot;todo-items&quot;,&#123;        props: [&#x27;item&#x27;],        template:&#x27;&lt;li&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;&#x27;    &#125;);    var vm = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            title:&quot;啦啦啦德玛西亚&quot;,            todoItems:[&#x27;java&#x27;,&#x27;Linux&#x27;,&#x27;web&#x27;]        &#125;    &#125;)&lt;/script&gt;&lt;/body&gt;\n\n\n自定义内容分发&lt;body&gt;&lt;!--view层模板--&gt;&lt;div id = &quot;app&quot;&gt;    &lt;todo&gt;        &lt;todo-title slot = &quot;todo-title&quot; title = &quot;title&quot;&gt;&lt;/todo-title&gt;        &lt;todo-items slot = &quot;todo-items&quot; v-for=&quot;(item,index) in todoitems&quot; v-bind:item=&quot;item&quot; v-bind:index=&quot;index&quot; v-on:r=&quot;removeitems(index)&quot;&gt;&lt;/todo-items&gt;    &lt;/todo&gt;&lt;/div&gt;&lt;script&gt;    // slot插槽    Vue.component(&quot;todo&quot;,&#123;        template:&#x27;&lt;div&gt;\\                        &lt;slot name=&quot;todo-title&quot;&gt;&lt;/slot&gt;\\                        &lt;ul&gt;\\                        &lt;slot name=&quot;todo-items&quot;&gt;&lt;/slot&gt;\\                        &lt;/ul&gt;\\                        &lt;/div&gt;&#x27;    &#125;);    Vue.component(&quot;todo-title&quot;,&#123;        props:[&#x27;title&#x27;],        template:&#x27;&lt;div&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;&#x27;    &#125;);    Vue.component(&quot;todo-items&quot;,&#123;        props: [&#x27;item&#x27;,&#x27;index&#x27;],        //组件里只能绑定到当前组件中的方法        template:&#x27;&lt;li&gt;&#123;&#123;index&#125;&#125;----&#123;&#123;item&#125;&#125;&lt;button @click=&quot;remove&quot;&gt;删除&lt;/button&gt;&lt;/li&gt;&#x27;,        methods:&#123;            remove:function(index)&#123;                this.$emit(&#x27;r&#x27;,index);            &#125;,            add:function(index)&#123;                alert(&quot;hahahahah&quot; + index);            &#125;        &#125;    &#125;);    var vm = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            title:&quot;干死vue啊&quot;,            todoitems:[&#x27;java&#x27;,&#x27;linux&#x27;,&#x27;web&#x27;]        &#125;,        methods:&#123;            removeitems:function(index)&#123;                console.log(&quot;删除了&quot; + this.todoitems[index]);                this.todoitems.splice(index,1);//一次删除一个元素            &#125;        &#125;    &#125;);&lt;/script&gt;&lt;/body&gt;\n\n\n使用Vue-Cli开发1.安装Node.js\n2.配置node.js环境变量\n3.安装node.js镜像加速器\nnpm install --registry=https://registry.npm.taobao.org或者&lt;!--    全局安装--&gt;npm install cnpm -g \n\n4.安装vue-cli\ncnpm install vue-cli -g\n\n5.创建vue项目\nVue init webpack projectName\n\n6.初始化\n进入项目目录，并执行  npm install命令\n\n7.启动web项目\n进入项目目录，并执行   npm run dev命令 \n\n\n\n安装webpacknpm intsall webpack -gnpm install webpack-cli -g测试：webpack -vwebpack-cli -v\n\nwebpack配置创建webpack.config.js配置文件  entry：入口文件，指定webpack用哪个文件作为项目的入口  output:输出，指定webpack把处理完成的文件放置到指定路径  module:模块，由于处理各种类型的文件  plugins:插件，如：热更新，代码重用等  resolve：设置路径指向  watch:监听，用于设置文件改动后直接打包\n\n使用webpack\n\n安装Vue-routernpm install vue-router --save-dev\n\n\n\n\n\n\n\n\n\n\n\n\n\n流程\n1.新建vue组件a.vue2.在app.vue中导入相应的组件a,并且在相应的comments中添加a3.配置路由，import想要使用路由的组件，并在routes的component属性中配置路由\n\n\n\n\n\n\n\n注意事项：el挂载点：\t1.Vue实例会管理el选项命中的元素以及其内部的后代元素\t2.可以使用非id选择器，但是建议使用id选择器\t3.可以使用奇特的双标签设置dom元素，但不能使用HTML和BODYel挂载点的作用：\t设置vue实例管理的元素，在html中&#123;&#123;&#125;&#125;中的元素就会被data中too同名的数据替换data：数据对象\t1.vue中用到的数据定义在data中\t2.data中可以使用复杂类型的数据\t3.渲染复杂数据类型时遵守js语法即可VUe指令合集1.v-text指令：设置标签的文本值(textContent)    &lt;!-- 这个是全部替换数据 --&gt;    &lt;h3 v-text=&quot;message + &#x27;!!!&#x27;&quot;&gt;哈哈哈&lt;/h3&gt;    &lt;!-- 替换部分数据 --&gt;    &lt;h3&gt;哈哈哈&#123;&#123;message&#125;&#125;&lt;/h3&gt;2.v-html指令：设置元素的innerHTML，data中有html结构的书会被解析为\t\t\t\t\t\t\t标签\t\t&lt;!-- 这个指令会解析message中的标签并渲染出来 --&gt;     &lt;p v-html=&quot;content&quot;&gt;&lt;/p&gt;3.v-on指令：为元素绑定事件,事件名不需要写on，指令可以简写为@，绑定的方法定义在methods属性中\t\t&lt;!-- v-on：为元素绑定事件 --&gt;    &lt;input type=&quot;button&quot; value=&quot;事件绑定&quot; v-on:事件类型=&quot;方法&quot;/&gt;\t\t&lt;!-- v-on：为元素绑定事件 ,并且v-on：可以替换成@ --&gt;    &lt;input type=&quot;button&quot; value=&quot;事件绑定&quot; v-on:click=&quot;doIt&quot;/&gt;补充：传递自定义参数，事件修饰符\t\t 传递参数：\t\t &lt;input type=&quot;button&quot; @click=&quot;doIt(p1,p2)&quot;&gt;&lt;/input&gt;\t\t ...\t\t methods:&#123;\t\t\t\t\t\tdoIt:function(p1,p2)&#123;&#125;&#125;\t\t 事件修饰符：(以下只有在按下回车才会触发)\t\t &lt;input type=&quot;text&quot; @keyup.enter=&quot;sayHi&quot;&gt;&lt;/input&gt;\t\t ...\t\t sayHi:function()&#123;&#125;4.v-show指令：根据表达式的真假，切换元素的显示和隐藏(本质是操作display属性)\t原理是修改元素的display来显示和隐藏组件，指令后面的内容最后都会解析为布尔值，如果为true，显示元素，值为false元素隐藏            &lt;img src=&quot;./assets/logo.png&quot; v-show=&quot;true&quot;/&gt;            &lt;img src=&quot;./assets/logo.png&quot; v-show=&quot;isShow&quot;/&gt;            &lt;img src=&quot;./assets/logo.png&quot; v-show=&quot;age &gt;= 18&quot;/&gt;5.v-if指令：根据表达式的真假，切换元素的显示和隐藏(本质是操作dom元素)            &lt;!-- v-if指令 --&gt;            &lt;button v-if=&quot;isShow&quot; &gt;v-if指令&lt;/button&gt;            &lt;button @click=&quot;toggleIsShow&quot;&gt;点击一下&lt;/button&gt;！！！！注意！！！！v-if和v-show的区别在：v-show只是在对组件的display属性进行变换，display=none但是组件仍然是存在的，但是v-if是对dom文档树进行的操作，如果为false则这个组件就不会创建6.v-bind指令：设置元素的属性(比如src,title,class等)\t\tv-bind:属性名=表达式\t\t\t\t\t&lt;!-- v-bind指令 --&gt;            &lt;!-- v-bind:属性名=表达式 --&gt;            &lt;div style=&quot;border:2px red solid;&quot;&gt;&lt;/div&gt;            &lt;div&gt;                &lt;img v-bind:src=&quot;imgSrc&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;&lt;br&gt;                &lt;img :src=&quot;imgSrc&quot; alt=&quot;&quot; :title=&quot;imgTitle + &#x27;&#x27;&quot; :class=&quot;isActive?&#x27;active&#x27;:&#x27;&#x27;&quot; @click=&quot;toggleActive&quot;/&gt;&lt;/br&gt;                &lt;img :src=&quot;imgSrc&quot; alt=&quot;&quot; :title=&quot;imgTitle + &#x27;&#x27;&quot; :class=&quot;&#123;active:isActive&#125;&quot; @click=&quot;toggleActive&quot;/&gt;            &lt;/div&gt;7:v-for指令:根据数据生成列表结构\t\t\t\t\t&lt;div&gt;                &lt;ul&gt;                    &lt;li v-for=&quot;item in imgArr&quot; :title=&quot;item&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;                &lt;/ul&gt;            &lt;/div&gt;\n\n图片切换demo\n&lt;div&gt;                &lt;img :src=&quot;imgArr[index]&quot; alt=&quot;&quot;&gt;                &lt;!-- 左箭头 --&gt;                &lt;a v-show=&quot;index!=0&quot; v-show=&quot;index!=0&quot; @click=&quot;prev&quot; class=&quot;left&quot;&gt;                    上一张                &lt;/a&gt;                &lt;!-- 右箭头 --&gt;                &lt;a v-show=&quot;index &lt; imgArr.length-1&quot; @click=&quot;next&quot; class=&quot;right&quot;&gt;                    下一张                &lt;/a&gt;            &lt;/div&gt; imgArr:[                        &quot;../src/assets/imgs/1.jpg&quot;,                        &quot;../src/assets/imgs/2.jpg&quot;,                        &quot;../src/assets/imgs/3.jpg&quot;,                        &quot;../src/assets/imgs/4.jpg&quot;,                        &quot;../src/assets/imgs/5.jpg&quot;,                    ],                    index:0,prev:function()&#123;                        this.index--;                    &#125;,                    next:function()&#123;                        this.index++;                    &#125;v-model指令：获取和设置表单元素的值(数据的双向绑定)\t\t\t\t\t\t &lt;div&gt;                &lt;input type=&quot; text&quot; v-model=&quot;message&quot;&gt;                &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt;            &lt;/div&gt;\t\t\t\t\t...\t\t\t\t\tdata:&#123;\t\t\t\t\t\t\tmessage: 哈哈哈,&#125;\n\n记事本应用\nvue-axios使用a:使用方法1：导入axios库&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;2：get请求方式axios.get(&quot;地址？key=value &amp; key2=value2&quot;).then(function(response)&#123;&#125;,function(err)&#123;&#125;)这里的地址就是文档提供的接口地址,第一个回调函数会在响应完成的时候触发，第二个回调函数会在请求失败的时候触发，形参可以用来获取信息，前者获取服务器响应的内容后者是响应失败的信息。地址后是需要传递的参数，key是文档提供的，value是具体传输的数据3:post请求方式axios.post(地址，&#123;key：value，key2：value2&#125;).then(function(response)&#123;&#125;,function(err)&#123;&#125;)与get请求不同的是，数据是以对象的形式传递注意：axios回调函数中的this已经改变，无法访问到vue实例中的数据，可以把this保存起来，回调函数中直接使用保存的this即可，和本地应用最大的区别就是改变了数据来源\n\n\n\n\n\n\n\n\n\nCSS定位方式1.因为绝对定位是根据最近一个定位了的元素进行的，所以采用相对定位和绝对定位结合的方式可以实现移动元素位置并且不占用位置。2.浮动定位：浮动的框可以向左或者向右移动，直到它的边缘碰到包含框或者另外一个浮动框的边框为止。3.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n业务流程(以上传用户照片为例)：  用户在客户端上传数据，经过校验，存储等过程之后，返回消息“上传成功”。  1.新建pojo类，对应数据库中应存放的照片大小，二进制内容等文件  2.Dao层，处理数据库数据，数据处理层  3.service层，实际功能，业务代码，  \n\n"},{"title":"Spring","url":"/2021/12/02/Spring/","content":"Spring优点\nspring是一个开源的免费框架\n轻量级的非入侵式的框架\n控制反转（IOC） 面向切面编程（AOP）\n支持事务的处理，对各种框架整合的支持\n总结：spring是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架\n\nspring组成Spring AOP、Spring ORM、Spring Web、Spring Dao、Spring Context、Spring MVC、Spring Core（核心容器）\nspring boot：一个快速开发的脚手架，基于spring boot可以快速开发单个的微服务，约定大于配置（构建一切）\nspring cloud：基于spring boot实现   \nIOC本质：控制反转是一种设计思想，DI（依赖注入）是实现IOC的一种方法，对象的创建和对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转交给第三方，所谓的控制反转也就是获得依赖对象的方式反转了\n控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式，在Spring中实现控制反转的是Ioc容器，其实现方法是依赖注入即DI\nSpring基础配置（spring有多种实现方式）\n基于xml实现\n1.配置基于xml的元数据applicationContext.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;** &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;     &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;               *&lt;!-- collaborators and configuration for this bean go here --&gt;*    &lt;/bean&gt;     &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;            *&lt;!-- collaborators and configuration for this bean go here --&gt;*    &lt;/bean&gt;     *&lt;!-- more bean definitions go here --&gt;* &lt;/beans&gt;\n\n\n\n\n\n\n参数\n\n\n\n该id属性是标识单个bean定义的字符串。即想要使用的对象对应的类名（首字母小写）\n\n\n该class属性定义Bean的类型并使用完全限定的类名。（该类的绝对路径）\n\n\n2.实例化容器若使用xml方式，则在测试类中必须先使用下列代码实例化IOC容器\n//获取Spring的上下文对象\nApplicationContext context = new ClassPathXmlApplicationContext(configLocation：…….);\n//要使用对象，则直接去IOC容器中去取\nObject object = context.getBean(name:”bean_id”);\nbean_id.function(xxx);\n\n\n\n参数\n\n\n\napplicationContext的位置\n\n\n程序通过spring来创建对象和属性，而本身不创建对象，只是单纯的接收对象，称为控制反转。\n依赖注入：利用set的方式来进行注入\nIOC创建对象的方式：（1）利用无参构造创建对象（默认）\n（2）假设使用有参构造的方式进行赋值\n有参的三种方式：\na：通过下标创建bean对象&lt;bean id=&quot;user&quot; class=&quot;com.cx.pojo.User&quot;&gt;​\t\t\t\t&lt;constructor-arg index=&quot;0&quot; value=&quot;hahahah&quot;&gt;​\t&lt;/bean&gt;\n\nb：通过类型创建bean对象&lt;bean id=&quot;user&quot; class=&quot;com.cx.pojo.User&quot;&gt;​\t\t&lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;hahaha&quot;&gt;&lt;/bean&gt;\n\nc:直接通过参数名创建&lt;bean id=&quot;user&quot; class=&quot;com.cx.pojo.User&quot;&gt;​\t\t&lt;constructor-arg name=&quot;name&quot; value=&quot;hahaha&quot;&gt;&lt;/bean&gt;\n\n总结：在配置文件加载的时候IOC容器就已经初始化了\nSpring其他配置(同applicationContext.xml中)（1）alias —— 别名&lt;alias name=&quot;user&quot; alias=&quot;another_name&quot;&gt;\n\n另外一种别名方式(此种方式可以取多个别名)\n&lt;bean id=&quot;user&quot; class=&quot;com.cx.pojo.User&quot; name=&quot;user1  user2,user3;u4&quot;&gt;&lt;/bean&gt;\n\n（2）import一般作用于团队开发，可以将多个spring配置文件，导入applicationContext合并为一个总的配置文件。假设项目中有多个人开发，这多个人负责不同的类的开发，不同的类需要·注册在不同的bean中，我们可以利用import将所有的beans.xml合并为一个applicationContext.xml，读取时读取这一个配置文件就可以了。\n&lt;import resource=&quot;beans.xml&quot;&gt;\n\n注意：spring中的中的内容可以是任意对象\n依赖注入依赖：bean对象的创建依赖于容器\n注入：bean对象的属性由容器来注入\n(1)构造器注入（1）利用无参构造创建对象（默认）\n即利用无参构造函数和set方法进行注入\n（2）假设使用有参构造的方式进行赋值\n有参的三种方式：\na：通过下标创建bean对象&lt;bean id=&quot;user&quot; class=&quot;com.cx.pojo.User&quot;&gt;​\t\t\t\t&lt;constructor-arg index=&quot;0&quot; value=&quot;hahahah&quot;&gt;​\t&lt;/bean&gt;\n\nb：通过类型创建bean对象&lt;bean id=&quot;user&quot; class=&quot;com.cx.pojo.User&quot;&gt;​\t\t&lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;hahaha&quot;&gt;&lt;/bean&gt;\n\nc:直接通过参数名创建&lt;bean id=&quot;user&quot; class=&quot;com.cx.pojo.User&quot;&gt;​\t\t&lt;constructor-arg name=&quot;name&quot; value=&quot;hahaha&quot;&gt;&lt;/bean&gt;\n\n(2)Set注入&lt;bean id=&quot;address&quot; class=&quot;com.cx.pojo.Address&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;com.cx.pojo.User&quot;&gt;    //第一种，普通值注入  value    &lt;property name=&quot;name&quot; value=&quot;hahah&quot;&gt;    //第二种，bean注入 ref    &lt;property name=&quot;name&quot; ref=&quot;address&quot;&gt;    //第三种，注入数组类型 array-value    &lt;property name=&quot;books&quot;&gt;       &lt;array&gt;          &lt;value&gt;红楼梦&lt;/value&gt;\t\t  &lt;value&gt;西游记&lt;/value&gt;       &lt;/array&gt;\t&lt;/property&gt;\t//第四种，注入List同三  list-value\t//注入map map-entry\t&lt;property&gt;        &lt;map&gt;        \t&lt;entry key=&quot;&quot; value=&quot;&quot;&gt;        &lt;/map&gt;    &lt;/property&gt;\t//注入Set集合同三  Set-value\t//注入null\t//注入properties\t&lt;property&gt;        &lt;props&gt;            &lt;prop key=&quot;name&quot;&gt;张三&lt;/prop&gt;\t\t\t&lt;prop key=&quot;url&quot;&gt;...&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;\n\n前俩种注入方式的优缺点：\n1：无参注入（默认）:易懂，但是在属性可选的时候，很多个构造函数会让类显得很臃肿\n2：有参注入：是一种高内聚的体现，特别是在有些属性需要在对象创建的时候赋值，并且后续不允许修改，那么就可以使用有参注入，并且在pojo类中不提供setter方法。\n(3)两种拓展方式p命名空间注入xmlns:p=”http://www.springframework.org/schema/p&quot;\n注入方式(是通过无参构造注入的)：\n&lt;bean id=&quot;user&quot; class=&quot;com.cx.pojo.User&quot; p:name=&quot;name&quot; p:age=&quot;18&quot;&gt;\n\nc命名空间注入xmlns:p=”http://www.springframework.org/schema/p&quot;\n注入方式（是通过有参构造注入的 ）：\n&lt;bean id=&quot;user&quot; class=&quot;com.cx.pojo.User&quot; c:name=&quot;name&quot; c:age=&quot;18&quot;&gt;\n\n\n\nBean Scopes（作用域）1.1 Singleton（单例模式 默认）&lt;bean id=&quot;user&quot; class=&quot;com.cx.pojo.User&quot; scope=&quot;singleton&quot;&gt;\n\n每次从容器中获取到的bean对象实际上都是同一个对象\n1.2 Prototype(原型模式)&lt;bean id=&quot;user&quot; class=&quot;com.cx.pojo.User&quot; scope=&quot;prototype&quot;&gt;\n\n每次从容器中get对象的时候。都会新产生一个对象\n1.3 其余的request、session、application这些作用域只可以在web开发中使用\nBean的自动装配自动装配是Spring满足Bean依赖的一种方式，设置自动装配的bean，在Spring中会在上下文中自动寻找，并且自动给bean装配属性\n在Spring中有三种装配的方式：\n1.在xml文件中显示的配置\n2.在java中显示的配置\n3.隐式的自动装配bean\n· xml方式第一种：在xml文件中设置自动装配类Cat Dog People，表示每个人都有cat和dog两个宠物Bean.xml&lt;bean id=&quot;cat&quot; class=&quot;com.cx.Pojo.Cat&quot;&gt;&lt;bean id=&quot;dog&quot; class=&quot;com.cx.Pojo.Dog&quot;&gt;&lt;bean id=&quot;People&quot; class=&quot;com.cx.Pojo.People&quot; autowire=&quot;byName&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;hahaha&quot;&gt;&lt;/bean&gt;    \n\n其中，byName：会在容器的上下文中查找，会在对应的Pojo类的setXXX和IOC容器中bean ID去比较，匹配上之后就会自动注入实现与name-ref相同的功能。    byType：会在容器中的上下文中查找，会在对应的Person类中找到对应的属性，拿到属性的类型然后去和去和相应的Cat或者Dog相匹配并且自动注入。\n小结：\n（1）byName时需要保证bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致\n（2）byType时需要保证bean的class唯一，并且这个bean需要和自动注入的属性的类型一致\n· 注解方式jdk1.5开始支持注解，spring2.5开始支持\n要使用注解条件：\n1.导入约束  &lt; context:annotation-config/ &gt;\n2.配置注解的支持\nxmlns:context=”http://www.springframework.org/schema/context&quot;\nxsi:schemaLocation=”http://www.springframework.org/schema/context    http://www.springframework.org/schema/context/spring-context.xsd “\n1 、@Autowired （通过类型，名字）自动装配直接在属性上面使用，也可以在set方法上面使用。并且在使用Autowired注解之后就可以省略pojo类的set方法，前提是这个自动装配的属性在IOC容器中存在，并且命名符合byname规则。2 、如果使用@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解@Autowired完成的时候，我们可以使用@Qualifier（Value=“XXX”）来搭配autowired来使用指定唯一的bean ID来注入容器    eg：@Autowired    \t@Qualifier(value=&quot;cat&quot;)    \tprivate Cat cat;3 、@Resource    默认使用byName的方式实现，如果找不到名字，则通过byType实现，如果两个都找不到，报错。Autowired使用byType的方式实现@Autowired和@Resource注解都可以放在属性字段上\n\n使用注解进行开发//扫描指定要扫描的包，这个包下的注解才会生效&lt;context:component-scan base-package=&quot;com.cx.pojo&quot;&gt;//开启注解的支持 &lt;context:annotation-config/&gt;     //bean的注入@Component//组件，放在类上，说明这个类被Spring容器管理了，就是Beanpublic class User&#123;    public String name;        //属性的注入    @value(&quot;hahahah&quot;)   // 相当于&lt;property name=&quot;name&quot; value=&quot;hahahah&quot;&gt;    publci void setName(String name)&#123;        this.name = name;    &#125;&#125;衍生的注解（功能同Conponent）    @Component有几个衍生的注解，在web开发中按照mvc三层架构分层    ·dao----@Respository    ·service----@Service    ·controller----@Controller    几个注解的功能都表示把相应的类注册到Spring中装配Bean    作用域：@Scope（“XXXX”）    完全以注解的形式进行开发\t//@Configration代表这是一个配置类，相当于之前的beans.xml文件// @Configration内部也包含了@Component，所以也会由spring来托管@Configration@ComponentScan(&quot;com.cx.pojo&quot;)public  class CxConfig&#123;        //@Bean注册一个bean，相当于xml文件中的bean标签    //这个方法的名字相当于bean标签中的id属性值    //这个方法的返回值相当于bean标签中的class属性    @Bean    public class getUser()&#123;\t\treturn new user();//返回的就是要注入到IOC中的bean对象    &#125;&#125;//如果完全使用注解的方式进行开发，那么只能使用AnnotationConfig上下文来获取容器，通过配置类的class对象加载ApplicationContext context = new AnnotationConfigApplicationContext（CxConfig.class）;User getUser =  (User)context.getBean(&quot;getUser&quot;);System.out.println(getUser.getName()); \n\n\n\n代理模式Spring AOP的底层就是代理模式\n代理模式的分类：\n（1）静态代理\n（2）动态代理\n静态代理静态代理模式的好处：\n\n可以使真实角色更加纯粹，不用去关注一些公共的业务\n\n公共业务交给代理角色，实现了业务的分工\n\n公共业务发生扩展的时候，方便集中管理\n缺点：\n\n一个真实角色就会产生一个代理角色，代码量会翻倍，开发效率降低\n静态代理示例代码：\n1.接口（租房 业务的接口）\n//租房public interface Rent&#123;  public void rent();&#125;\n\n2:真实角色\n//房东public class Host implements Rent&#123;  public void rent()&#123;    System.out.println(&quot;房东要出租房子了&quot;)  &#125;&#125;\n\n3:代理角色\npublic class Proxy implements Rent&#123;  private Host host;    public Proxy()&#123;&#125;  public Proxy(Host host)&#123;    this.host = host;  &#125;    public void rent()&#123;    host.rent();    seeHouse();  &#125;    //中介带客户去看房  public void seeHouse()&#123;   System.out.println(&quot;中介带你去看房&quot;);  &#125;&#125;\n\n4:客户端访问代理角色\npublic class Client&#123;  public static void main(String[] args)&#123;    //房东要出租房子，新建房东对象    Host host =  new Host();    //代理，中介代替房东出租房子，一般代理角色还会有一些附属操作，例如这里可能会有带客户看房，代替收租等    Proxy proxy = new Proxy(host);        //想要租房直接去找代理角色--中介去租房    proxy.rent();  &#125;&#125;\n\n动态代理：\n动态代理和静态代理角色一样\n动态代理的代理类是动态生成的而不是由程序员事先定义好的\n动态代理分为两大类：基于接口的动态代理，基于类的动态代理\n基于接口：JDK动态代理\n基于类：CG LIb动态代理\njava字节码实现：javassist（是在JBoss的一个子项目，优点是简单快速，直接使用java编码的形式不需要了解虚拟机指令就能使用）\n\n\n\n需了解的两个类：Proxy，InvocationHandler\nInvocationHandler : 是由代理实例调用处理程序的接口，每个代理实例都有一个关联的调用处理程序，当在代理实例上调用方法时，方法调用将被编码并分派到其调动处理程序的invoke（）方法。\n———————————-此处的InvocationHandler接口的作用即充当了房屋中介的作用。\nProxy : 提供了创建动态代理类和实例的静态方法，它也是由这些方法创建的所有动态代理类的超类。\n//1 、接口（租房 有关业务的接口）public interface Rent&#123;  public void rent();&#125;//2 、真实角色  房东public class Host implements Rent&#123;  public void rent()&#123;    System.out.println(&quot;房东要出租房子了&quot;)  &#125;&#125;/*3、代理角色**在这里的ProxyInvocationHandler实现InvocationHandler，本类只是一个处理程序，通过这个处理程序来生成代理类*/public class ProxyInvocationHandler implements InvocationHandler&#123;  //被代理的接口(包含出租功能的接口)  private Rent rent;    public void setRent(Rent rent)&#123;    this.rent = rent;  &#125;    //生成得到代理类  public Object getProxy()&#123;    /*    *参数含义：    *1 、 加载到类的位置    *2 、 表示要代理的接口    *3 、 处理程序    */        return Proxy.newProxyInstance(this.getClass().getClassLoader,rent.getClass().getInterfaces(),this);   &#125;    //处理代理实例，并返回结果  public Object invoke(Object proxy,Method method,Object[] args) throws Throwable&#123;    Object result = method.invoke(rent,args);    return result;  &#125;&#125;//4 、客户端访问代理角色public class Client&#123;  public static void main(String[] args)&#123;    //真实角色    Host host = new Host();        //代理角色    ProxyInvocationHandler proxy = new ProxyInvocationHandler();    //通过调用处理程序来绑定要调用的业务接口    proxy.setRent(host);      &#125;&#125;\n\n动态代理相较于静态代理的好处：\n\n一个动态代理类代理的是一个接口，一般就是对应的一类业务，即一个动态代理类可以代理多个类，只要是实现了同一个业务接口即可\n\n","categories":["Spring"],"tags":["Spring"]},{"url":"/2022/04/21/cusSystem/","content":"cusSystem项目步骤\n引入静态前端模板\n引入thymeleaf依赖\nhtml文件加上命名空间\n\n&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;\n\n\n\n\n&lt;a class=&quot;nav-brand&quot; href=&quot;index.html&quot;&gt;&lt;img th:src=&quot;@&#123;/images/logo-header.png&#125;&quot; alt=&quot;logo&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;tile-link&quot;&gt;&lt;/a&gt;&lt;img  th:src=&quot;@&#123;/images/photo/6.jpg&#125;&quot; alt=&quot;Card image&quot; class=&quot;bg-image&quot;&gt;"},{"title":"dubbo","url":"/2022/04/01/dubbo/","content":"Dubbo (RPC框架)1.基础知识1.分布式系统分布式系统是若干独立计算机的集合，他们对于用户来说像是单个相关系统，分布式系统是建立在网络上的软件系统，dubbo就是一个治理系统来保证分布式系统的正常服务。\n\n2.Eureke和Zookeeper的区别分布式领域中有一个理论，即C:数据一致性，A:服务可用性，P:分区容错性(服务对网络分区故障的容错性)，在目前的所有分布式系统中，任何系统只能保证其中的两个，由于网络延迟故障会导致丢包等万体，所以分区容错性是必须实现的，所以只能在一致性和可用性中做出选择\nEureka保证了AP，Zookeeper保证了CP\nZookeeper保证CP\n​            当向注册中心查询服务列表时，可以容忍注册中心返回的是几分钟以前的注册信息，但是不能接收服务直接down掉不可用，即服务注册功能会对可用性的要求高于一致性。zookeeper可能会出现这样一种情况，即当master节点因为网络故障与其他节点失去联系时剩余的节点会重新进行leader选举，但是时间过长，一般在30~120s，且选举期间整个zookeeper集群都是不可用的，即注册服务瘫痪，云部署时大概率会因为网络问题出现这个问题，虽然服务能够恢复，但是注册服务长期不可用是不能容忍的\n*Eureka保证Ap:\n​        Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。Eureka客户端在向某个Eukera注册时如果发现连接失败会自动切换至其他节点，只要还有一台Eureka在就能保证注册服务可用(可用性保证)，只不过查询到的信息可能不是最新的(不保证强一致性).除此之外还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，则认为是客户端与注册中心除了网络故障，可能会有以下操作:\n1.Eureka不再从注册列表中移除因为长时间没有收到心跳而应该过期的服务。\n2.Eureka仍然能接受新服务的注册和查询请求，但是不会被同步到其他节点上(即保证当前节点依然可用)，当网络稳定时，当前实例新的注册信息会被同步到其他节点\n\n3，RPCRPC是指远程过程调用（即A服务器上的应用调用B服务器上的服务），是一种进程间的通信方式，是一种技术的思想而不是规范。它允许程序调用另一个地址空间（通常是指共享网络的另外一台机器上）的过程或者函数，而不是说程序员显示的编码这个远程调用的细节，即无论调用的是远程的函数还是本地的函数本质上编写的调用代码基本一致。\n两个核心模块：服务器间的通讯，数据的序列化和反序列化\n4.Dubbo核心概念a.容器(container)初始化启动  -&gt; 服务提供者(provider)将提供的所有服务注册到注册中心(Registry) \nb.服务消费者(Consumer)启动时会向注册中心订阅所需要的服务，注册中心会通过长连接的形式实时推送所提供的服务给消费者 \n其中消费者调用服务是同步调用过程，监控中心统计是异步操作\n\n2.Demo需求：订单服务需要调用用户服务模块来获取此用户的所有地址模块\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t功能订单服务web模块(A服务器)\t\t\t\t\t\t\t创建订单用户服务service模块(B服务器)\t\t\t\t\t查询用户所有地址\n\n改造步骤：\n1.将服务提供者注册到注册中心。\n1.引入dubbo依赖&lt;!--        引入dubbo依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;dubbo&lt;/artifactId&gt;            &lt;version&gt;2.6.2&lt;/version&gt;        &lt;/dependency&gt;2.引入操作zookeeper的客户端&lt;!--        因为注册中心使用的是zookeeper，所以需要引入操作zookeeper的客户端--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;            &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;            &lt;version&gt;2.12.0&lt;/version&gt;        &lt;/dependency&gt;3.配置服务提供者&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt;&lt;!--    1.指定当前服务/应用的名字--&gt;&lt;dubbo:application name=&quot;user-service-provider&quot;&gt;&lt;/dubbo:application&gt;&lt;!--    指明注册中心的位置(1.2两种写法均可)--&gt;&lt;!--&lt;dubbo:registry address=&quot;zookeeper://127.0.0.1.:2181&quot;&gt;&lt;/dubbo:registry&gt;--&gt;&lt;dubbo:registry protocol=&quot;zookeeper&quot; address=&quot;127.0.0.1:2181&quot;&gt;&lt;/dubbo:registry&gt;&lt;!--    指定服务提供者和消费者的通信规则(通信协议、端口)--&gt;&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20080&quot;&gt;&lt;/dubbo:protocol&gt;    &lt;!--    声明要暴露出去的服务接口（其中，ref表示服务真正的实现对象）--&gt;&lt;dubbo:service interface=&quot;com.dubboTest.gmall.service.UserService&quot; ref=&quot;userServiceImpl&quot; &gt;&lt;/dubbo:service&gt;&lt;bean id=&quot;userServiceImpl&quot; class=&quot;com.dubboTest.gmall.service.impl.UserServiceImpl&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;4.配置服务消费者&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt;&lt;context:component-scan base-package=&quot;com.dubboTest.gmall.service.impl&quot;&gt;&lt;/context:component-scan&gt;&lt;dubbo:application name=&quot;order-service-consumer&quot;&gt;&lt;/dubbo:application&gt;&lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot;&gt;&lt;/dubbo:registry&gt;  &lt;!--  声明需要调用的远程服务的接口，生成远程服务的代理 --&gt;  &lt;dubbo:reference interface=&quot;com.dubboTest.gmall.service.UserService&quot; id=&quot;userService&quot;&lt;/beans&gt;\n\n\n\n3.常用注解@EnableDubbo@EnableDubbo 注解是 @EnableDubboConfig 和 @DubboComponentScan两者组合的便捷表达方式。与注解驱动相关的是 @DubboComponentScan。\n通过 @EnableDubbo 可以在指定的包名下（通过 scanBasePackages），或者指定的类中（通过 scanBasePackageClasses）扫描 Dubbo 的服务提供者（以 @Service 标注）以及 Dubbo 的服务消费者（以 Reference 标注）。\n扫描到 Dubbo 的服务提供方和消费者之后，对其做相应的组装并初始化，并最终完成服务暴露或者引用的工作。\n当然，如果不使用外部化配置（External Configuration）的话，也可以直接使用 @DubboComponentScan。\n@Service（只能定义在一个类上，表示一个服务的具体实现）\ninterfaceClass：指定服务提供方实现的 interface 的类\ninterfaceName：指定服务提供方实现的 interface 的类名\nversion：指定服务的版本号\ngroup：指定服务的分组\nexport：是否暴露服务\nregistry：是否向注册中心注册服务\napplication：应用配置\nmodule：模块配置\nprovider：服务提供方配置\nprotocol：协议配置\nmonitor：监控中心配置\n\napplication、module、provider、protocol、monitor、registry需要提供的是对应的 spring bean 的名字，而这些 bean 的组装要么通过传统的 XML 配置方式完成要么通过现代的 Java Config 来完成\n@Reference（用来配置 Dubbo 的服务消费方）@Reference 可以定义在类中的一个字段上，也可以定义在一个方法上，甚至可以用来修饰另一个 annotation，表示一个服务的引用。通常 @Reference 定义在一个字段上\n\ninterfaceClass：指定服务的 interface 的类\ninterfaceName：指定服务的 interface 的类名\nversion：指定服务的版本号\ngroup：指定服务的分组\nurl：通过指定服务提供方的 URL 地址直接绕过注册中心发起调用\napplication：应用配置\nmodule：模块配置\nconsumer：服务消费方配置\nprotocol：协议配置\nmonitor：监控中心配置\nregistry：注册中心配置\n\napplication、module、consumer、protocol、monitor、registry需要提供的是对应的 spring bean 的名字\n2.让服务消费者去注册中心订阅服务提供者的服务地址\n"},{"title":"maven静态资源过滤","url":"/2021/12/06/maven%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%BF%87%E6%BB%A4/","content":"&lt;build&gt;    &lt;resources&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/java&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;**/*.properties&lt;/include&gt;                &lt;include&gt;**/*.xml&lt;/include&gt;            &lt;/includes&gt;            &lt;filtering&gt;false&lt;/filtering&gt;        &lt;/resource&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/resources&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;**/*.properties&lt;/include&gt;                &lt;include&gt;**/*.xml&lt;/include&gt;            &lt;/includes&gt;            &lt;filtering&gt;false&lt;/filtering&gt;        &lt;/resource&gt;    &lt;/resources&gt;&lt;/build&gt;\n\n","tags":["maven"]},{"title":"springboot","url":"/2022/04/07/springboot/","content":"SpringBoot一、架构1.1、单应用架构单体应用架构是指将一个应用中的所有应用服务都封装在一个应用中\n优点：\n1.便于开发，测试和部署，当需要扩展时，只需要把war包复制多份，然后放在多个服务器上再做个负载均衡即可\n缺点：\n1.即时需要做的改动只是很小的，也需要停掉整个服务，重新打包部署\n1.2、 微服务架构把每个服务拆分开来，根据实际需要来动态调整需要的服务功能\n优点\n节省资源，每个功能元素都是一个可替换，可独立升级的部分\n二、第一个SpringBoot程序创建SpringBoot项目的两种方式\n1、进入https://start.spring.io/，项目名组名等根据需要更改，依赖添加spring-web即可点击生成，下载的zip包解压后就是标准idea项目。\n注：可能遇见的问题 —–\n\n下载好的项目导入idea后无法识别java文件，java文件左下角显示黄色的“J” -&gt;解决办法：右击java文件夹标识目录为源文件文件夹\n下载好的项目导入后无法识别maven的pom文件 -&gt;解决办法:右击pom文件 -&gt;“add as maven project”\n\n2、idea创建新项目选择“Spring Initializr”后按要求配置，最后选中依赖添加“spring-web”\n在springApplication.java统计目录下新建controller等包新建接口package com.example.demo.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController &#123;    @RequestMapping(&quot;/h1&quot;)    public String  hello() &#123;        return &quot;world&quot;;    &#125;&#125;访问地址：http://localhost:8080/t1\n\n2.1、application.properties配置\nproperties语法\n\n#properties只能保存键值对name=wangxustudent.name=wangxustudent.age=12\n\n\nyaml语法\n\nkey：空格 valueeg：name: wangxu#对象student: \tname: wangxu\tage: 12\t#对应的行内写法student: &#123;name: wangxu,age: 12&#125;#数组animals:\t- cat\t- dog\t#对应的行内写法animals: [cat,dog]\n\n\n通过properties绑定到java类上\n\n第一种方式 ———-yaml\npackage com.example.demo.pojo;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class Dog &#123;    @Value(&quot;旺财&quot;)    private String name;    private int age;    public Dog() &#123;    &#125;    public Dog(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    @Value(&quot;12&quot;)    public void setAge(int age) &#123;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public int getAge() &#123;        return age;    &#125;    @Override    public String toString() &#123;        return &quot;Dog&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, age=&quot; + age +                &#x27;&#125;&#x27;;    &#125;&#125;package com.example.demo.pojo;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;import java.util.Date;import java.util.List;import java.util.Map;@Component@ConfigurationProperties(prefix = &quot;person&quot;)public class Person &#123;    private String name;    private Integer age;    private Date birth;    private Map&lt;String,Object&gt; maps;    private List&lt;Object&gt; lists;    private Dog dog;    public Person() &#123;    &#125;    @Override    public String toString() &#123;        return &quot;Person&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, age=&quot; + age +                &quot;, birth=&quot; + birth +                &quot;, maps=&quot; + maps +                &quot;, lists=&quot; + lists +                &quot;, dog=&quot; + dog +                &#x27;&#125;&#x27;;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public Integer getAge() &#123;        return age;    &#125;    public void setAge(Integer age) &#123;        this.age = age;    &#125;    public Date getBirth() &#123;        return birth;    &#125;    public void setBirth(Date birth) &#123;        this.birth = birth;    &#125;    public Map&lt;String, Object&gt; getMaps() &#123;        return maps;    &#125;    public void setMaps(Map&lt;String, Object&gt; maps) &#123;        this.maps = maps;    &#125;    public List&lt;Object&gt; getLists() &#123;        return lists;    &#125;    public void setLists(List&lt;Object&gt; lists) &#123;        this.lists = lists;    &#125;    public Dog getDog() &#123;        return dog;    &#125;    public void setDog(Dog dog) &#123;        this.dog = dog;    &#125;    public Person(String name, Integer age, Date birth, Map&lt;String, Object&gt; maps, List&lt;Object&gt; lists, Dog dog) &#123;        this.name = name;        this.age = age;        this.birth = birth;        this.maps = maps;        this.lists = lists;        this.dog = dog;    &#125;&#125;    --------yaml----------person:  name: &quot;汪旭&quot;  age: 12  birth: 1998/01/18  maps: &#123;k1: v1,k2: v2&#125;  list:    - sing    - dance  dog:    name: wangcai    age: 13\n\n第二种方式———-properties\npackage com.example.demo.pojo;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.PropertySource;import org.springframework.stereotype.Component;@Component@PropertySource(value = &quot;classpath:dog.properties&quot;)public class Dog &#123;    //SPEL表达式取出相应的配置文件中的值    @Value(&quot;$&#123;name&#125;&quot;)    private String name;    private int age;    public Dog() &#123;    &#125;    public Dog(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    @Value(&quot;12&quot;)    public void setAge(int age) &#123;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public int getAge() &#123;        return age;    &#125;    @Override    public String toString() &#123;        return &quot;Dog&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, age=&quot; + age +                &#x27;&#125;&#x27;;    &#125;&#125;---------properties-----------name=&quot;旺财&quot;\n\n\n\n***@ConfigurationProperties与@Value对比**\n\n松散绑定（如personName匹配yaml中person-name）        支持        不支持\nSpEL取数         不支持        支持\nJSR303校验         支持        不支持\n复杂类型封装        支持        不支持\n\nSpringBoot多环境配置springboot配置文件位置：\n\nfile:./config/\nfile:./\nclasspath:/config/\nclasspath:/\n\n（注:其中file指的是项目路径，classpath指的是类路径，即java或者resource路径下）\napplication.properties中增加\n​        spring.profiles=“配置名称”\n​        spring.profiles.active=“具体环境”\n如果是用yml文件则只需要在一个文件中写多个环境即可，多个环境之间用 - - -（三个）分割开即可\n2.2、 JSR303校验类上添加@Validated表示开启JSR303校验\n判断参数是否合法\n\n@Null\n@NotNull\n@Email()\n\n@Null    被注释的元素必须是null@NotNull    被注释的元素必须不为null@AssertTrue    被注释的元素必须为true@AssertFalse    被注释的元素必须为false@Min（Value）    被注释的元素必须是一个数字，值必须大于等于指定值@Max（Value）@Size（max，min）    被注释的元素的大小必须在指定的范围内@Digits（integer，fraction）    被注释的元素必须是一个数字，值必须在可接受的范围内@Past      被注释的元素必须是一个过去的日期@Future@Pattern(value)  被注释的元素必须符合指定的正则表达式@Email    必须是电子邮箱@Length   字符串大小必须在指定的范围内@NotEmpty    字符串必须非空@Range   被注释的元素必须在合适的范围内\n\n等\n2.3、关于classpath：\nclasspath: 可表示src/main/java或者src/main/resources路径\n\nclasspath:/xxx 和 classpath:xxx是一样的\n\nclasspath:xxx 和 classpath*:xxx是不一样的，前者表示引入一个，后者表示引入多个。\n\n打成war包之后：classpath : 指的是web-info 文件夹下面的classes 文件夹里面的路径\n\n\n另外，&quot;xx/&quot; 表示的是任意目录；    &quot;xx/applicationContext-*.xml&quot; 表示任意目录下的以&quot;applicationContext-&quot;开头的XML文件\n3、SpringBoot Web开发在springboot中，可以使用如下方式处理静态资源：\n\npublic 、static、/* 、resources下的静态资源直接使用localhost:8080/资源名   来访问，*资源路径访问优先级：resources&gt;static &gt;public\nwebjars(即通过maven引入的静态资源，例如通过maven引入的JQuery资源)   localhost:8080/webjars/资源名\n\n\n3.1、 thymeleaf\n导入thymeleaf依赖\n\n&lt;!--        thymeleaf,默认使用3.x版本的           --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt;            &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;            &lt;artifactId&gt;thymeleaf-extras-java8time&lt;/artifactId&gt;        &lt;/dependency&gt;\n\n2.templates文件夹下创建对应的html文件\n&lt;!DOCTYPE html&gt;&lt;!--导入thymeleaf命名空间--&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n3.新建对应的Controller\npackage com.example.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class IndexController &#123;    @RequestMapping(&quot;/h1&quot;)    public String test(Model model)&#123;        model.addAttribute(&quot;msg&quot;,&quot;爷好烦啊&quot;);        return &quot;test&quot;;    &#125;&#125;\n\n*Thymeleaf语法示例：\npackage com.example.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import java.util.Arrays;@Controllerpublic class IndexController &#123;    @RequestMapping(&quot;/h1&quot;)    public String test(Model model)&#123;        model.addAttribute(&quot;msg&quot;,&quot;爷好烦啊&quot;);        //遍历        model.addAttribute(&quot;forea&quot;, Arrays.asList(&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;));        //非转义        model.addAttribute(&quot;uns&quot;,&quot;&lt;h1&gt;hello&lt;/h1&gt;&quot;);        return &quot;test&quot;;    &#125;&#125;\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/div&gt;&lt;h1 th:text=&quot;$&#123;uns&#125;&quot;&gt;&lt;/h1&gt;&lt;h1 th:utext=&quot;$&#123;uns&#125;&quot;&gt;&lt;/h1&gt;&lt;ul&gt;    &lt;li th:each=&quot;user:$&#123;forea&#125;&quot; th:text=&quot;$&#123;user&#125;&quot;&gt;&lt;/li&gt;    \t\t&lt;li th:each=&quot;user:$&#123;forea&#125;&quot;&gt;[[ $&#123;user&#125; ]]&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;\n\n3.2、扩展SpringMVC功能扩展功能需要实现WebMvcConfigurer接口，类注解需要加上@Configuration并且一定不能加上@EnableWebMvc\npackage com.example.config;import org.springframework.context.annotation.Configuration;import org.springframework.ui.Model;import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; @Configurationpublic class MyConfig implements WebMvcConfigurer &#123;    //接管视图跳转    @Override    public void addViewControllers(ViewControllerRegistry registry) &#123;        registry.addViewController(&quot;haha&quot;).setViewName(&quot;test&quot;);    &#125;&#125;\n\n"},{"title":"正儿八斤写博客！设计模式","url":"/2021/12/02/%E6%AD%A3%E5%84%BF%E5%85%AB%E6%96%A4%E5%86%99%E5%8D%9A%E5%AE%A2%EF%BC%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","content":""},{"title":"整合spring+mybatis","url":"/2021/12/09/%E6%95%B4%E5%90%88spring-mybatis/","content":"框架整合1.新建数据库SpringBoot整合\n1、引入mybatis依赖\n&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;2.1.2&lt;/version&gt;&lt;/dependency&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"webService","url":"/2022/04/06/webService/","content":"WebService1.啥是WebServiceWebService也称为Web服务，是一种跨编程语言和操作系统平台的远程调用技术，采用标准的SOAP协议传输。WebService采用WSDL作为描述语言，任何语言写的WebService接口在发送数据的时候都要转换成WebService标准的XSD发送\n2.WebService的三要素2.1 SOAPSimple Object  Access Protocal ——- 简单对象访问协议，属于w3c标准，并且soap协议是基于http的应用层协议传输xml数据。它使应用程序通过HTTP来交换数据，可以理解为SOAP=http + xml。\n2.1.1 SOAP协议格式1.必须有Envelope元素,此元素将整个xml文档表示为一条SOAP消息。\n2.可选Header元素，包含头部信息\n3.必须有Body元素，包含所有的调用和响应信息。\n4.可选Fault元素，提供有关在处理此消息所发生的错误信息\n2.2 WSDLWeb Service描述语言WSDL　就是用机器能阅读的方式提供的一个正式描述文档而基于XML（标准通用标记语言下的一个子集）的语言，用于描述Web Service及其函数、参数和返回值\n2.3 UDDIUDDI 的目的是为电子商务建立标准；UDDI是一套基于Web的、分布式的、为Web Service提供的、信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的Web Service注册，以使别的企业能够发现的访问协议的实现标准。\n*webService相对于post/get来说，因为要进行xml解析，所以速度可能会有所降低。调用接口的时候需要转换成xml对象，接收接口的时候需要把xml转回一般对象。\n3.常用注解3.1@Path(类/方法)标注class时，表示该类是资源类，资源类都必须使用该注解\n标注method时，表示具体的资源请求路径\n3.2 @GET/  @POST/  @PUT/  @DELETE(方法)标注method，指明接收HTTP请求的方式，具体的请求方式是由客户端发起请求时指定\n3.3 @Consumes(方法)指定HTTP请求的MIME类型，默认是“/”，表示任意的MIME类型。该注解支持多个值设定，可以使用MediaType类指定MIME类型\n@Path(&quot;&#123;username&#125;&quot;) @Consumes(&#123;MediaType.APPLICATION_JSON&#125;)public User getUser(@PathParam(&quot;username&quot;) String userName) &#123;     ... &#125;\n\n\n\n注：MIME\n​        ——即多用途互联网邮件扩展，它是一个互联网标准，在1992年最早应用于电子邮件系统，但后来也应用到浏览器。服务器会将它们发送的多媒体数据的类型告诉浏览器，而通知手段就是说明该多媒体数据的MIME类型，从而让浏览器知道接收到的信息哪些是MP3文件，哪些是Shockwave文件等等。将MIME标志符放入传送的数据中来告诉浏览器使用哪种插件读取相关文件。\nMediaType类型大致有：\n\napplication/xml、\napplication/atom+xml\napplication/json\napplication/svg+xml\napplication/x-www-form-urlencoded\napplication/octet-stream\nmultipart/form-data\ntext/plain\ntext/xml\ntext/html\n\n3.4  @Produces(方法)指定HTTP响应的MIME类型，默认是“/”，表示是任意的MIME类型，指定方法同@Consumes\n@Path(&quot;&#123;username&#125;&quot;) @Consumes(&#123;MediaType.APPLICATION_JSON&#125;)@Produces(MediaType.APPLICATION_JSON) public User getUser(@PathParam(&quot;username&quot;) String userName) &#123;     ... &#125;\n\n3.5 @PathParam(参数)配合path使用，可以获取URI中指定规则的参数\n@GET @Path(&quot;&#123;username&#125;&quot;) @Produces(MediaType.APPLICATION_JSON) public User getUser(@PathParam(&quot;username&quot;) String userName) &#123;     ... &#125; // 浏览器请求http://ip:port/user/jack时，userName值为jack。 // 注意，这里的username并不是说Key是username, value是jack而是说/usr/后面跟着的东西就是username,这里username只是个变量 \n\n\n\n3.6 @QueryParam(参数)用于获取GET请求中的查询参数，实际上是url拼接在？后面的参数\n@GET @Path(&quot;/user&quot;) @Produces(&quot;text/plain&quot;) public User getUser(@QueryParam(&quot;name&quot;) String name,                     @QueryParam(&quot;age&quot;) int age) &#123;     ... &#125; //当浏览器请求http://ip:port/user?name=rose&amp;age=25时，name值为rose，age值为25。如果需要为参数设置默认值，可以使用@DefaultValue\n\n3.7 @Form Param(参数)用于获取POST请求且以form(MIME类型为application/x-www-form-urlencoded)方式提交的表单的参数。\n@POST@Consumes(&quot;application/x-www-form-urlencoded&quot;) public void post(@FormParam(&quot;name&quot;) String name) &#123;     ...&#125; // 这应该是提交form表单中常见的方式，就不详述了。\n\n3.8 @FormDataParam (参数)用于获取POST请求且以form(MIME类型为multipart/form-data)的方式提交的表单的参数，常用于获取文件的时候。\n3.9 @HeaderParam(参数)用于获取HTTP请求头中的参数值\n@GET @Path(&quot;/user/get&quot;) public Response getUser(@HeaderParam(&quot;user-agent&quot;) String userAgent) &#123;   ...&#125; // 这里获取user-agent的值\n\n3.10  CookieParam(参数)用于获取HTTP请求中cookie中的参数值\n@GETpublic String callService(@CookieParam(&quot;sessionid&quot;) String sessionid) &#123;  ...&#125;\n\n3.11  @MatrixParam可以用来绑定包含多个property (属性)=value(值) 方法参数表达式，用于获取请求URL参数中的键值对，必须使用”;”作为键值对分隔符。\n@Path(&quot;/books&quot;)public class BookService &#123;    @GET    @Path(&quot;&#123;year&#125;&quot;)    public Response getBooks(@PathParam(&quot;year&quot;) String year,            @MatrixParam(&quot;author&quot;) String author,            @MatrixParam(&quot;country&quot;) String country) &#123;\t...    &#125;&#125;// 请求1：“/books/2012/”， 解析结果为：年份：2012，作者：null，国家：null// 请求2：“/books/2012;author=andih”， 解析结果为：年份：2012，作者：andih，国家：null\n\n注意MatrixParam与QueryParam的区别：QueryParam请求url的格式为: url?key1=value1&amp;key2=value2&amp;…MatrixParam请求url的格式为: url;key1=value1;key2=value2;…\n3.12 @DefaultValue (参数)配合前面的参数注解使用，用来设置默认值，如果请求指定的参数中没有值，通过该注解给定默认值\n@POST@Path(&quot;/user/add&quot;)@Consumes(&#123;MediaType.APPLICATION_FORM_URLENCODED&#125;)@Produces(&#123;MediaType.APPLICATION_JSON&#125;)public Response addUser(@FormParam(&quot;username&quot;) String userName, @DefaultValue(&quot;0&quot;) @FormParam(&quot;age&quot;) int age,@DefaultValue(&quot;1&quot;) @FormParam(&quot;sex&quot;) int sex)&#123;    ...&#125;\n\n注意：DefaultValue指定的值在解析过程中出错时(@DefaultValue(“test”) @QueryParam(“age”) int age)，将返回404错误。\n3.13  @BeanParam(参数)如果传递的较多，使用@FormParam等参数注解一个一个的接收每个参数可能显得太臃肿，可以通过Bean方式接收自定义的Bean，在自定义的Bean中字段使用@FormParam等参数注解。只需定义一个参数接收即可。\npublic class MyBean &#123;   @FormParam(&quot;myData&quot;)   private String data;   @HeaderParam(&quot;myHeader&quot;)   private String header;   @PathParam(&quot;id&quot;)   public void setResourceId(String id) &#123;...&#125;   ... &#125; @Path(&quot;myresources&quot;) public class MyResources &#123;   @POST   @Path(&quot;&#123;id&#125;&quot;)   public void post(@BeanParam MyBean myBean) &#123;\t...   &#125;   ... &#125;\n\n\n\n3.14  @Context (属性/参数)用来用来解析上下文参数，和Spring中的AutoWired效果类似。通过该注解可以获取ServletConfig、ServletContext、HttpServletRequest、HttpServletResponse和HttpHeaders等信息。\n@Path(&quot;/user&quot;) public class Resource &#123;     @Context     HttpServletRequest req;     @Context     ServletConfig servletConfig;     @Context     ServletContext servletContext;     @GET     public String get(@Context HttpHeaders hh) &#123;         MultivaluedMap&lt;String, String&gt; headerParams = hh.getRequestHeaders();         Map&lt;String, Cookie&gt; pathParams = hh.getCookies();     &#125; &#125; \n\n3.15  Encoded禁止解码，客户端发送的是什么样服务端接收的就是什么样\n"},{"title":"解决web乱码问题","url":"/2021/12/09/%E8%A7%A3%E5%86%B3web%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/","content":"乱码问题\ntomcat设置utf-8编码\n浏览器设置utf-8编码格式\n配置过滤器解决乱码\n\n示例：\n乱码-&gt;\npackage[/jsp/hello.jsp]&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt;package[/formDemo.jsp]&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/formDemo&quot; method=&quot;post&quot;&gt;    &lt;input type=&quot;text&quot; name=&quot;text&quot;/&gt;    &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\npackage com.wx.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class FormDemo &#123;    @RequestMapping(&quot;/formDemo&quot;)    public String test(String text,Model model)&#123;        model.addAttribute(&quot;msg&quot;,&quot;和为：&quot;+ text);        return &quot;hello&quot;;    &#125;&#125;\n\nform表单输入汉字会出现乱码问题\n解决方式一:使用SpringMVC自带过滤器web.xml中添加如下配置&lt;!--    配置过滤器解决乱码--&gt;    &lt;filter&gt;        &lt;filter-name&gt;encoding&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;encoding&lt;/param-name&gt;            &lt;param-value&gt;utf-8&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;encoding&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;\n\n方式二：使用自定义过滤器(实现servlet的filter接口)package com.wx.filter;import javax.servlet.*;import java.io.IOException;public class EncodingFilter implements Filter &#123;    public void init(FilterConfig filterConfig) throws ServletException &#123;    &#125;    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;        request.setCharacterEncoding(&quot;utf-8&quot;);        response.setCharacterEncoding(&quot;utf-8&quot;);        //让链式继续往下走        chain.doFilter(request, response);    &#125;    public void destroy() &#123;    &#125;&#125;\n\n配置web.xml\n&lt;!--    配置过滤器解决乱码--&gt;    &lt;filter&gt;        &lt;filter-name&gt;encoding&lt;/filter-name&gt;        &lt;filter-class&gt;com.wx.filter.EncodingFilter&lt;/filter-class&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;encoding&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;\n\n*配置过滤器时需注意要不要把jsp请求加入到过滤器中，url-pattern要注意/和/的区别\nJSON乱码问题解决：在application-context.xml中添加处理方法：\n&lt;!--    JSON乱码问题解决--&gt;    &lt;mvc:annotation-driven&gt;        &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;            &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;                &lt;constructor-arg value=&quot;UTF-8&quot;/&gt;            &lt;/bean&gt;            &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;                &lt;property name=&quot;objectMapper&quot;&gt;                    &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;                        &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt;                    &lt;/bean&gt;                &lt;/property&gt;            &lt;/bean&gt;        &lt;/mvc:message-converters&gt;    &lt;/mvc:annotation-driven&gt;"},{"title":"终于！！！","url":"/2021/12/01/%E7%BB%88%E4%BA%8E%EF%BC%81%EF%BC%81%EF%BC%81/","content":"终于！！！！！！！！家人们，把公屏打在泪目上！！！！"}]
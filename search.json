[{"title":"Spring MVC","url":"/2021/12/02/Spring-MVC/","content":"Spring  MVC1.回顾servlet\n编写一个普通的类继承servlet接口，重写doGet()和doPost()方法\n在web.xml中配置servlet\n\nseevlet-Demo1.导入servlet依赖&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;parent&gt;        &lt;artifactId&gt;SpringMvc&lt;/artifactId&gt;        &lt;groupId&gt;org.example&lt;/groupId&gt;        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;/parent&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;artifactId&gt;springmvc_01_servlet&lt;/artifactId&gt;&lt;!--    导入依赖--&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;            &lt;version&gt;2.5&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;            &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;            &lt;version&gt;2.2&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;\n\n2.编写servlet类，继承httpservlet类，重写doGet()和doPost()方法import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class HelloServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //1.获取前端参数        String method = req.getParameter(&quot;method&quot;);        if(method.equals(&quot;add&quot;))&#123;            req.getSession().setAttribute(&quot;msg&quot;,&quot;执行了add方法&quot;);        &#125;        if(method.equals(&quot;delete&quot;))&#123;            req.getSession().setAttribute(&quot;msg&quot;,&quot;执行了delete方法&quot;);        &#125;      //2.调用业务逻辑      //3.视图转发或者重定向    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        doGet(req,resp);    &#125;&#125;\n\n3.编写视图层前端页面&lt;!--  请求页  --&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;登录页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/hello&quot;&gt;    &lt;input type=&quot;text&quot; name=&quot;method&quot;&gt;    &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;!--  视图转发页面  --&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt;\n\n4.配置servlet配置文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;         version=&quot;4.0&quot;&gt;    &lt;!--    配置servlet，依靠servlet-name配对，   servlet-class定位servlet类(java文件夹下即为根路径)，   url-pattern配置请求路径--&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;        &lt;servlet-class&gt;HelloServlet&lt;/servlet-class&gt;    &lt;/servlet&gt;        &lt;servlet-mapping&gt;        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;        &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;    &lt;!--    配置请求超时时间--&gt;    &lt;session-config&gt;        &lt;session-timeout&gt;15&lt;/session-timeout&gt;    &lt;/session-config&gt;&lt;!--    设置欢迎页--&gt;    &lt;welcome-file-list&gt;        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;    &lt;/welcome-file-list&gt;    &lt;/web-app&gt;\n\n5.发送请求验证\nhttp://localhost:8080/hello?method=add\nhttp://localhost:8080/hello?method=delete\n\n"},{"title":"Spring","url":"/2021/12/02/Spring/","content":"Spring优点\nspring是一个开源的免费框架\n轻量级的非入侵式的框架\n控制反转（IOC） 面向切面编程（AOP）\n支持事务的处理，对各种框架整合的支持\n总结：spring是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架\n\nspring组成Spring AOP、Spring ORM、Spring Web、Spring Dao、Spring Context、Spring MVC、Spring Core（核心容器）\nspring boot：一个快速开发的脚手架，基于spring boot可以快速开发单个的微服务，约定大于配置（构建一切）\nspring cloud：基于spring boot实现   \nIOC本质：控制反转是一种设计思想，DI（依赖注入）是实现IOC的一种方法，对象的创建和对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转交给第三方，所谓的控制反转也就是获得依赖对象的方式反转了\n控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式，在Spring中实现控制反转的是Ioc容器，其实现方法是依赖注入即DI\nSpring基础配置（spring有多种实现方式）\n基于xml实现\n1.配置基于xml的元数据applicationContext.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;** &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;     &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;               *&lt;!-- collaborators and configuration for this bean go here --&gt;*    &lt;/bean&gt;     &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;            *&lt;!-- collaborators and configuration for this bean go here --&gt;*    &lt;/bean&gt;     *&lt;!-- more bean definitions go here --&gt;* &lt;/beans&gt;\n\n\n\n\n\n\n参数\n\n\n\n该id属性是标识单个bean定义的字符串。即想要使用的对象对应的类名（首字母小写）\n\n\n该class属性定义Bean的类型并使用完全限定的类名。（该类的绝对路径）\n\n\n2.实例化容器若使用xml方式，则在测试类中必须先使用下列代码实例化IOC容器\n//获取Spring的上下文对象\nApplicationContext context = new ClassPathXmlApplicationContext(configLocation：…….);\n//要使用对象，则直接去IOC容器中去取\nObject object = context.getBean(name:”bean_id”);\nbean_id.function(xxx);\n\n\n\n参数\n\n\n\napplicationContext的位置\n\n\n程序通过spring来创建对象和属性，而本身不创建对象，只是单纯的接收对象，称为控制反转。\n依赖注入：利用set的方式来进行注入\nIOC创建对象的方式：（1）利用无参构造创建对象（默认）\n（2）假设使用有参构造的方式进行赋值\n有参的三种方式：\na：通过下标创建bean对象&lt;bean id=&quot;user&quot; class=&quot;com.cx.pojo.User&quot;&gt;​\t\t\t\t&lt;constructor-arg index=&quot;0&quot; value=&quot;hahahah&quot;&gt;​\t&lt;/bean&gt;\n\nb：通过类型创建bean对象&lt;bean id=&quot;user&quot; class=&quot;com.cx.pojo.User&quot;&gt;​\t\t&lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;hahaha&quot;&gt;&lt;/bean&gt;\n\nc:直接通过参数名创建&lt;bean id=&quot;user&quot; class=&quot;com.cx.pojo.User&quot;&gt;​\t\t&lt;constructor-arg name=&quot;name&quot; value=&quot;hahaha&quot;&gt;&lt;/bean&gt;\n\n总结：在配置文件加载的时候IOC容器就已经初始化了\nSpring其他配置(同applicationContext.xml中)（1）alias —— 别名&lt;alias name=&quot;user&quot; alias=&quot;another_name&quot;&gt;\n\n另外一种别名方式(此种方式可以取多个别名)\n&lt;bean id=&quot;user&quot; class=&quot;com.cx.pojo.User&quot; name=&quot;user1  user2,user3;u4&quot;&gt;&lt;/bean&gt;\n\n（2）import一般作用于团队开发，可以将多个spring配置文件，导入applicationContext合并为一个总的配置文件。假设项目中有多个人开发，这多个人负责不同的类的开发，不同的类需要·注册在不同的bean中，我们可以利用import将所有的beans.xml合并为一个applicationContext.xml，读取时读取这一个配置文件就可以了。\n&lt;import resource=&quot;beans.xml&quot;&gt;\n\n注意：spring中的中的内容可以是任意对象\n依赖注入依赖：bean对象的创建依赖于容器\n注入：bean对象的属性由容器来注入\n(1)构造器注入（1）利用无参构造创建对象（默认）\n即利用无参构造函数和set方法进行注入\n（2）假设使用有参构造的方式进行赋值\n有参的三种方式：\na：通过下标创建bean对象&lt;bean id=&quot;user&quot; class=&quot;com.cx.pojo.User&quot;&gt;​\t\t\t\t&lt;constructor-arg index=&quot;0&quot; value=&quot;hahahah&quot;&gt;​\t&lt;/bean&gt;\n\nb：通过类型创建bean对象&lt;bean id=&quot;user&quot; class=&quot;com.cx.pojo.User&quot;&gt;​\t\t&lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;hahaha&quot;&gt;&lt;/bean&gt;\n\nc:直接通过参数名创建&lt;bean id=&quot;user&quot; class=&quot;com.cx.pojo.User&quot;&gt;​\t\t&lt;constructor-arg name=&quot;name&quot; value=&quot;hahaha&quot;&gt;&lt;/bean&gt;\n\n(2)Set注入&lt;bean id=&quot;address&quot; class=&quot;com.cx.pojo.Address&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;com.cx.pojo.User&quot;&gt;    //第一种，普通值注入  value    &lt;property name=&quot;name&quot; value=&quot;hahah&quot;&gt;    //第二种，bean注入 ref    &lt;property name=&quot;name&quot; ref=&quot;address&quot;&gt;    //第三种，注入数组类型 array-value    &lt;property name=&quot;books&quot;&gt;       &lt;array&gt;          &lt;value&gt;红楼梦&lt;/value&gt;\t\t  &lt;value&gt;西游记&lt;/value&gt;       &lt;/array&gt;\t&lt;/property&gt;\t//第四种，注入List同三  list-value\t//注入map map-entry\t&lt;property&gt;        &lt;map&gt;        \t&lt;entry key=&quot;&quot; value=&quot;&quot;&gt;        &lt;/map&gt;    &lt;/property&gt;\t//注入Set集合同三  Set-value\t//注入null\t//注入properties\t&lt;property&gt;        &lt;props&gt;            &lt;prop key=&quot;name&quot;&gt;张三&lt;/prop&gt;\t\t\t&lt;prop key=&quot;url&quot;&gt;...&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;\n\n前俩种注入方式的优缺点：\n1：无参注入（默认）:易懂，但是在属性可选的时候，很多个构造函数会让类显得很臃肿\n2：有参注入：是一种高内聚的体现，特别是在有些属性需要在对象创建的时候赋值，并且后续不允许修改，那么就可以使用有参注入，并且在pojo类中不提供setter方法。\n(3)两种拓展方式p命名空间注入xmlns:p=”http://www.springframework.org/schema/p&quot;\n注入方式(是通过无参构造注入的)：\n&lt;bean id=&quot;user&quot; class=&quot;com.cx.pojo.User&quot; p:name=&quot;name&quot; p:age=&quot;18&quot;&gt;\n\nc命名空间注入xmlns:p=”http://www.springframework.org/schema/p&quot;\n注入方式（是通过有参构造注入的 ）：\n&lt;bean id=&quot;user&quot; class=&quot;com.cx.pojo.User&quot; c:name=&quot;name&quot; c:age=&quot;18&quot;&gt;\n\n\n\nBean Scopes（作用域）1.1 Singleton（单例模式 默认）&lt;bean id=&quot;user&quot; class=&quot;com.cx.pojo.User&quot; scope=&quot;singleton&quot;&gt;\n\n每次从容器中获取到的bean对象实际上都是同一个对象\n1.2 Prototype(原型模式)&lt;bean id=&quot;user&quot; class=&quot;com.cx.pojo.User&quot; scope=&quot;prototype&quot;&gt;\n\n每次从容器中get对象的时候。都会新产生一个对象\n1.3 其余的request、session、application这些作用域只可以在web开发中使用\nBean的自动装配自动装配是Spring满足Bean依赖的一种方式，设置自动装配的bean，在Spring中会在上下文中自动寻找，并且自动给bean装配属性\n在Spring中有三种装配的方式：\n1.在xml文件中显示的配置\n2.在java中显示的配置\n3.隐式的自动装配bean\n· xml方式第一种：在xml文件中设置自动装配类Cat Dog People，表示每个人都有cat和dog两个宠物Bean.xml&lt;bean id=&quot;cat&quot; class=&quot;com.cx.Pojo.Cat&quot;&gt;&lt;bean id=&quot;dog&quot; class=&quot;com.cx.Pojo.Dog&quot;&gt;&lt;bean id=&quot;People&quot; class=&quot;com.cx.Pojo.People&quot; autowire=&quot;byName&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;hahaha&quot;&gt;&lt;/bean&gt;    \n\n其中，byName：会在容器的上下文中查找，会在对应的Pojo类的setXXX和IOC容器中bean ID去比较，匹配上之后就会自动注入实现与name-ref相同的功能。    byType：会在容器中的上下文中查找，会在对应的Person类中找到对应的属性，拿到属性的类型然后去和去和相应的Cat或者Dog相匹配并且自动注入。\n小结：\n（1）byName时需要保证bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致\n（2）byType时需要保证bean的class唯一，并且这个bean需要和自动注入的属性的类型一致\n· 注解方式jdk1.5开始支持注解，spring2.5开始支持\n要使用注解条件：\n1.导入约束  &lt; context:annotation-config/ &gt;\n2.配置注解的支持\nxmlns:context=”http://www.springframework.org/schema/context&quot;\nxsi:schemaLocation=”http://www.springframework.org/schema/context    http://www.springframework.org/schema/context/spring-context.xsd “\n1 、@Autowired （通过类型，名字）自动装配直接在属性上面使用，也可以在set方法上面使用。并且在使用Autowired注解之后就可以省略pojo类的set方法，前提是这个自动装配的属性在IOC容器中存在，并且命名符合byname规则。2 、如果使用@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解@Autowired完成的时候，我们可以使用@Qualifier（Value=“XXX”）来搭配autowired来使用指定唯一的bean ID来注入容器    eg：@Autowired    \t@Qualifier(value=&quot;cat&quot;)    \tprivate Cat cat;3 、@Resource    默认使用byName的方式实现，如果找不到名字，则通过byType实现，如果两个都找不到，报错。Autowired使用byType的方式实现@Autowired和@Resource注解都可以放在属性字段上\n\n使用注解进行开发//扫描指定要扫描的包，这个包下的注解才会生效&lt;context:component-scan base-package=&quot;com.cx.pojo&quot;&gt;//开启注解的支持 &lt;context:annotation-config/&gt;     //bean的注入@Component//组件，放在类上，说明这个类被Spring容器管理了，就是Beanpublic class User&#123;    public String name;        //属性的注入    @value(&quot;hahahah&quot;)   // 相当于&lt;property name=&quot;name&quot; value=&quot;hahahah&quot;&gt;    publci void setName(String name)&#123;        this.name = name;    &#125;&#125;衍生的注解（功能同Conponent）    @Component有几个衍生的注解，在web开发中按照mvc三层架构分层    ·dao----@Respository    ·service----@Service    ·controller----@Controller    几个注解的功能都表示把相应的类注册到Spring中装配Bean    作用域：@Scope（“XXXX”）    完全以注解的形式进行开发\t//@Configration代表这是一个配置类，相当于之前的beans.xml文件// @Configration内部也包含了@Component，所以也会由spring来托管@Configration@ComponentScan(&quot;com.cx.pojo&quot;)public  class CxConfig&#123;        //@Bean注册一个bean，相当于xml文件中的bean标签    //这个方法的名字相当于bean标签中的id属性值    //这个方法的返回值相当于bean标签中的class属性    @Bean    public class getUser()&#123;\t\treturn new user();//返回的就是要注入到IOC中的bean对象    &#125;&#125;//如果完全使用注解的方式进行开发，那么只能使用AnnotationConfig上下文来获取容器，通过配置类的class对象加载ApplicationContext context = new AnnotationConfigApplicationContext（CxConfig.class）;User getUser =  (User)context.getBean(&quot;getUser&quot;);System.out.println(getUser.getName()); \n\n\n\n代理模式Spring AOP的底层就是代理模式\n代理模式的分类：\n（1）静态代理\n（2）动态代理\n静态代理静态代理模式的好处：\n\n可以使真实角色更加纯粹，不用去关注一些公共的业务\n\n公共业务交给代理角色，实现了业务的分工\n\n公共业务发生扩展的时候，方便集中管理\n缺点：\n\n一个真实角色就会产生一个代理角色，代码量会翻倍，开发效率降低\n静态代理示例代码：\n1.接口（租房 业务的接口）\n//租房public interface Rent&#123;  public void rent();&#125;\n\n2:真实角色\n//房东public class Host implements Rent&#123;  public void rent()&#123;    System.out.println(&quot;房东要出租房子了&quot;)  &#125;&#125;\n\n3:代理角色\npublic class Proxy implements Rent&#123;  private Host host;    public Proxy()&#123;&#125;  public Proxy(Host host)&#123;    this.host = host;  &#125;    public void rent()&#123;    host.rent();    seeHouse();  &#125;    //中介带客户去看房  public void seeHouse()&#123;   System.out.println(&quot;中介带你去看房&quot;);  &#125;&#125;\n\n4:客户端访问代理角色\npublic class Client&#123;  public static void main(String[] args)&#123;    //房东要出租房子，新建房东对象    Host host =  new Host();    //代理，中介代替房东出租房子，一般代理角色还会有一些附属操作，例如这里可能会有带客户看房，代替收租等    Proxy proxy = new Proxy(host);        //想要租房直接去找代理角色--中介去租房    proxy.rent();  &#125;&#125;\n\n动态代理：\n动态代理和静态代理角色一样\n动态代理的代理类是动态生成的而不是由程序员事先定义好的\n动态代理分为两大类：基于接口的动态代理，基于类的动态代理\n基于接口：JDK动态代理\n基于类：CG LIb动态代理\njava字节码实现：javassist（是在JBoss的一个子项目，优点是简单快速，直接使用java编码的形式不需要了解虚拟机指令就能使用）\n\n\n\n需了解的两个类：Proxy，InvocationHandler\nInvocationHandler : 是由代理实例调用处理程序的接口，每个代理实例都有一个关联的调用处理程序，当在代理实例上调用方法时，方法调用将被编码并分派到其调动处理程序的invoke（）方法。\n———————————-此处的InvocationHandler接口的作用即充当了房屋中介的作用。\nProxy : 提供了创建动态代理类和实例的静态方法，它也是由这些方法创建的所有动态代理类的超类。\n//1 、接口（租房 有关业务的接口）public interface Rent&#123;  public void rent();&#125;//2 、真实角色  房东public class Host implements Rent&#123;  public void rent()&#123;    System.out.println(&quot;房东要出租房子了&quot;)  &#125;&#125;/*3、代理角色**在这里的ProxyInvocationHandler实现InvocationHandler，本类只是一个处理程序，通过这个处理程序来生成代理类*/public class ProxyInvocationHandler implements InvocationHandler&#123;  //被代理的接口(包含出租功能的接口)  private Rent rent;    public void setRent(Rent rent)&#123;    this.rent = rent;  &#125;    //生成得到代理类  public Object getProxy()&#123;    /*    *参数含义：    *1 、 加载到类的位置    *2 、 表示要代理的接口    *3 、 处理程序    */        return Proxy.newProxyInstance(this.getClass().getClassLoader,rent.getClass().getInterfaces(),this);   &#125;    //处理代理实例，并返回结果  public Object invoke(Object proxy,Method method,Object[] args) throws Throwable&#123;    Object result = method.invoke(rent,args);    return result;  &#125;&#125;//4 、客户端访问代理角色public class Client&#123;  public static void main(String[] args)&#123;    //真实角色    Host host = new Host();        //代理角色    ProxyInvocationHandler proxy = new ProxyInvocationHandler();    //通过调用处理程序来绑定要调用的业务接口    proxy.setRent(host);      &#125;&#125;\n\n动态代理相较于静态代理的好处：\n\n一个动态代理类代理的是一个接口，一般就是对应的一类业务，即一个动态代理类可以代理多个类，只要是实现了同一个业务接口即可\n\n"},{"title":"Vue","url":"/2021/12/01/Vue/","content":"Vue语法//导入vue.js &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt;//使用vue指令必须导入命名空间v-bind=&quot;http://www.w3.org/1999/xhtml\n\n基础指令合集v-bind、v-if、v-else、v-for&lt;!--vue层  模板--&gt;&lt;div id=&quot;app&quot;&gt;&lt;!--    v-bind指令  用于将标签的某个属性和vue对象的某个属性绑定--&gt;    &lt;span v-bind:title=&quot;message&quot;&gt;&lt;!--            v-if指令，v-else指令--&gt;        &lt;h1 v-if=&quot;ok===true&quot;&gt;Yes&lt;/h1&gt;        &lt;h1 v-else&gt;No&lt;/h1&gt;    &lt;/span&gt;&lt;!--    v-for指令--&gt;    &lt;li v-for=&quot;item in items&quot;&gt;        &#123;&#123;item.messages&#125;&#125;    &lt;/li&gt;&lt;/div&gt;&lt;div id = &quot;func&quot;&gt;    &lt;button v-on:click=&quot;sayHi&quot;&gt;点击事件测试&lt;/button&gt;&lt;/div&gt;&lt;body&gt;&lt;script&gt;    // 创建vue对象    var vm = new Vue(&#123;         el:&quot;#app&quot;,//el即组件        // model 数据        data:&#123;            message:&quot;hello,vue!&quot;,            ok:true,            items:[                &#123;messages:&#x27;java&#x27; &#125;,                &#123;messages:&#x27;vue&#x27;&#125;,                &#123;messagea:&#x27;html&#x27; &#125;            ]        &#125;    &#125;);    var vs = new Vue(&#123;        el:func,        date:&#123;            message:&quot;vue方法绑定&quot;        &#125;,        methods:&#123;            //这里的事件必须在vue的对象中定义            sayHi:function () &#123;                alert(this.message);            &#125;        &#125;    &#125;)&lt;/script&gt;\n\n组件即可复用的Vue实例，就是一组可以重复使用的模板，跟JSTL的自定义标签，Thymeleaf的th:fragment等框架类似。\n//定义一个vue组件Vue.component(&quot;component_Name&quot;,&#123;  template:&quot;一段html模板&quot;&#125;);\n\n实例代码：\n&lt;body&gt;&lt;div id = &quot;app&quot;&gt;    &lt;wangxu&gt;&lt;/wangxu&gt;&lt;/div&gt;//组件中如果想接收外部传递的数据必须使用props属性来接收,并且也无法直接从其他组件或者vue对象中获取数据，需要通过中间件来动态绑定数据，即此处的  v-bind:dat=&quot;item&quot;&lt;div id = &quot;app2&quot;&gt;    &lt;vslist v-for=&quot;item in items&quot; v-bind:dat=&quot;item&quot;&gt;&lt;/vslist&gt;&lt;/div&gt;&lt;script&gt;    //定义一个Vue的组件Component    Vue.component(&quot;wangxu&quot;,&#123;        template:&#x27;&lt;div&gt;&lt;li&gt;ahahahah&lt;/li&gt;&#x27; +            &#x27;&lt;li&gt;sssss&lt;/li&gt;&lt;/div&gt;&#x27;    &#125;);    var vm = new Vue(&#123;        el:&quot;#app&quot;    &#125;);    Vue.component(&quot;vslist&quot;,&#123;        props:[&#x27;dat&#x27;],        template:&#x27;&lt;li&gt;&#123;&#123;dat&#125;&#125;&lt;/li&gt;&#x27;    &#125;)    var vm2 = new Vue(&#123;        el:&quot;#app2&quot;,        data:&#123;            items:[&#x27;java&#x27;,&#x27;linux&#x27;,&#x27;web&#x27;]        &#125;    &#125;)&lt;/script&gt;&lt;/body&gt;\n\nAxiosaxios是一个开源的可以用在浏览器端和NodeJS的异步通信框架，主要作用就是实现AJAX异步通信，功能特点如下：\n\n从浏览器中创建XMLHttpRequests\n从node.js创建http请求\n支持JS中链式变成\n拦截请求和响应\n转换请求数据和响应数据\n取消请求\n自动转换json数据\n客户端支持防御跨站请求伪造\n\n&lt;body&gt;&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt;&lt;div id = &quot;vue&quot; v-clock&gt;    &lt;div&gt;&#123;&#123;info.name&#125;&#125;&lt;/div&gt;    &lt;div&gt;&#123;&#123;info.address.city&#125;&#125;&lt;/div&gt;    &lt;a v-bind:href=&quot;info.url&quot;&gt;点击跳转&lt;/a&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var vm = new Vue(&#123;        el:&#x27;#vue&#x27;,        data()&#123;            //data()方法通过return来接收mounted（）返回的数据              return&#123;                  //请求的返回参数格式必须和json字符串一样                  info:&#123;                      name:null,                      address:&#123;                          city:null,                          country:null                      &#125;,                      url:null                  &#125;              &#125;        &#125;,        //Vue专注于视图层，数据交互叫交付于axios        mounted()&#123;//钩子函数 链式编程 ES6新特性            axios.get(&#x27;data.json&#x27;).then(response=&gt;(console.log(this.info=response.data)));        &#125;    &#125;);&lt;/script&gt;&lt;/body&gt;\n\n计算属性//在调用方法时，每次都需要进行计算，但是计算过程会有系统开销，如果这个这个计算结果不是经常变化的，就可以考虑把结果缓存起来，采用计算属性可以很方便的做到这一点，计算属性的主要特性就是为了将不经常变化的计算结果进行缓存以节约系统开销。&lt;body&gt;&lt;div id = &quot;app&quot;&gt;    &lt;p&gt;current_time&#123;&#123;current_time()&#125;&#125;&lt;/p&gt;    &lt;p&gt;current_time2&#123;&#123;current_time2&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt;    var vm = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            message:&quot;hello,wangxu&quot;        &#125;,        methods:&#123;            current_time:function()&#123;                return Date.now();//返回一个时间戳            &#125;        &#125;,        computed:&#123;//计算属性,类似于mybatis中缓存的概念，这里是虚拟dom，一但计算属性中涉及到数据更改，就立刻刷新dom重新计算            current_time2:function()&#123;                this.message;                return Date.now();            &#125;        &#125;    &#125;)&lt;/script&gt;\n\n内容分发使用这一种方式混合父组件与子组件自己的模板，这个过程被称为“内容分发”，在子组件中使用的特殊的元素作为容器的插槽\n&lt;body&gt;&lt;div id = &quot;app&quot;&gt;    &lt;todo&gt;        &lt;todo-title slot=&quot;todo-title&quot; v-bind:title = &quot;title&quot;&gt;&lt;/todo-title&gt;        &lt;todo-items slot=&quot;todo-items&quot; v-for=&quot;item in todoItems&quot; :item = &quot;item&quot;&gt;&lt;/todo-items&gt;    &lt;/todo&gt;&lt;/div&gt;&lt;!--即不是用插槽是以下样式--&gt;&lt;!--&lt;div&gt;--&gt;&lt;!--    &lt;title&gt;&lt;/title&gt;--&gt;&lt;!--    &lt;ul&gt;--&gt;&lt;!--        &lt;li&gt;java&lt;/li&gt;--&gt;&lt;!--        &lt;li&gt;linux&lt;/li&gt;--&gt;、&lt;!--        &lt;li&gt;web&lt;/li&gt;--&gt;&lt;!--    &lt;/ul&gt;--&gt;&lt;!--&lt;/div&gt;--&gt;&lt;script&gt;    //slot插槽    Vue.component(&quot;todo&quot;,&#123;        template:&#x27;&lt;div&gt;\\                        &lt;slot name=&quot;todo-title&quot;&gt;&lt;/slot&gt;\\                        &lt;ul&gt;\\                        &lt;slot name=&quot;todo-items&quot;&gt;&lt;/slot&gt;\\                        &lt;/ul&gt;\\                        &lt;/div&gt;&#x27;    &#125;);    Vue.component(&quot;todo-title&quot;,&#123;        props: [&#x27;title&#x27;],        template:&#x27;&lt;div&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;&#x27;    &#125;);    Vue.component(&quot;todo-items&quot;,&#123;        props: [&#x27;item&#x27;],        template:&#x27;&lt;li&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;&#x27;    &#125;);    var vm = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            title:&quot;啦啦啦德玛西亚&quot;,            todoItems:[&#x27;java&#x27;,&#x27;Linux&#x27;,&#x27;web&#x27;]        &#125;    &#125;)&lt;/script&gt;&lt;/body&gt;\n\n\n自定义内容分发&lt;body&gt;&lt;!--view层模板--&gt;&lt;div id = &quot;app&quot;&gt;    &lt;todo&gt;        &lt;todo-title slot = &quot;todo-title&quot; title = &quot;title&quot;&gt;&lt;/todo-title&gt;        &lt;todo-items slot = &quot;todo-items&quot; v-for=&quot;(item,index) in todoitems&quot; v-bind:item=&quot;item&quot; v-bind:index=&quot;index&quot; v-on:r=&quot;removeitems(index)&quot;&gt;&lt;/todo-items&gt;    &lt;/todo&gt;&lt;/div&gt;&lt;script&gt;    // slot插槽    Vue.component(&quot;todo&quot;,&#123;        template:&#x27;&lt;div&gt;\\                        &lt;slot name=&quot;todo-title&quot;&gt;&lt;/slot&gt;\\                        &lt;ul&gt;\\                        &lt;slot name=&quot;todo-items&quot;&gt;&lt;/slot&gt;\\                        &lt;/ul&gt;\\                        &lt;/div&gt;&#x27;    &#125;);    Vue.component(&quot;todo-title&quot;,&#123;        props:[&#x27;title&#x27;],        template:&#x27;&lt;div&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;&#x27;    &#125;);    Vue.component(&quot;todo-items&quot;,&#123;        props: [&#x27;item&#x27;,&#x27;index&#x27;],        //组件里只能绑定到当前组件中的方法        template:&#x27;&lt;li&gt;&#123;&#123;index&#125;&#125;----&#123;&#123;item&#125;&#125;&lt;button @click=&quot;remove&quot;&gt;删除&lt;/button&gt;&lt;/li&gt;&#x27;,        methods:&#123;            remove:function(index)&#123;                this.$emit(&#x27;r&#x27;,index);            &#125;,            add:function(index)&#123;                alert(&quot;hahahahah&quot; + index);            &#125;        &#125;    &#125;);    var vm = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            title:&quot;干死vue啊&quot;,            todoitems:[&#x27;java&#x27;,&#x27;linux&#x27;,&#x27;web&#x27;]        &#125;,        methods:&#123;            removeitems:function(index)&#123;                console.log(&quot;删除了&quot; + this.todoitems[index]);                this.todoitems.splice(index,1);//一次删除一个元素            &#125;        &#125;    &#125;);&lt;/script&gt;&lt;/body&gt;\n\n\n使用Vue-Cli开发1.安装Node.js\n2.配置node.js环境变量\n3.安装node.js镜像加速器\nnpm install --registry=https://registry.npm.taobao.org或者&lt;!--    全局安装--&gt;npm install cnpm -g \n\n4.安装vue-cli\ncnpm install vue-cli -g\n\n5.创建vue项目\nVue init webpack projectName\n\n6.初始化\n进入项目目录，并执行  npm install命令\n\n7.启动web项目\n进入项目目录，并执行   npm run dev命令 \n\n\n\n安装webpacknpm intsall webpack -gnpm install webpack-cli -g测试：webpack -vwebpack-cli -v\n\nwebpack配置创建webpack.config.js配置文件  entry：入口文件，指定webpack用哪个文件作为项目的入口  output:输出，指定webpack把处理完成的文件放置到指定路径  module:模块，由于处理各种类型的文件  plugins:插件，如：热更新，代码重用等  resolve：设置路径指向  watch:监听，用于设置文件改动后直接打包\n\n使用webpack\n\n安装Vue-routernpm install vue-router --save-dev\n\n\n\n\n\n\n\n\n\n\n\n\n\n流程\n1.新建vue组件a.vue2.在app.vue中导入相应的组件a,并且在相应的comments中添加a3.配置路由，import想要使用路由的组件，并在routes的component属性中配置路由\n\n\n\n\n\n\n\n注意事项：el挂载点：\t1.Vue实例会管理el选项命中的元素以及其内部的后代元素\t2.可以使用非id选择器，但是建议使用id选择器\t3.可以使用奇特的双标签设置dom元素，但不能使用HTML和BODYel挂载点的作用：\t设置vue实例管理的元素，在html中&#123;&#123;&#125;&#125;中的元素就会被data中too同名的数据替换data：数据对象\t1.vue中用到的数据定义在data中\t2.data中可以使用复杂类型的数据\t3.渲染复杂数据类型时遵守js语法即可VUe指令合集1.v-text指令：设置标签的文本值(textContent)    &lt;!-- 这个是全部替换数据 --&gt;    &lt;h3 v-text=&quot;message + &#x27;!!!&#x27;&quot;&gt;哈哈哈&lt;/h3&gt;    &lt;!-- 替换部分数据 --&gt;    &lt;h3&gt;哈哈哈&#123;&#123;message&#125;&#125;&lt;/h3&gt;2.v-html指令：设置元素的innerHTML，data中有html结构的书会被解析为\t\t\t\t\t\t\t标签\t\t&lt;!-- 这个指令会解析message中的标签并渲染出来 --&gt;     &lt;p v-html=&quot;content&quot;&gt;&lt;/p&gt;3.v-on指令：为元素绑定事件,事件名不需要写on，指令可以简写为@，绑定的方法定义在methods属性中\t\t&lt;!-- v-on：为元素绑定事件 --&gt;    &lt;input type=&quot;button&quot; value=&quot;事件绑定&quot; v-on:事件类型=&quot;方法&quot;/&gt;\t\t&lt;!-- v-on：为元素绑定事件 ,并且v-on：可以替换成@ --&gt;    &lt;input type=&quot;button&quot; value=&quot;事件绑定&quot; v-on:click=&quot;doIt&quot;/&gt;补充：传递自定义参数，事件修饰符\t\t 传递参数：\t\t &lt;input type=&quot;button&quot; @click=&quot;doIt(p1,p2)&quot;&gt;&lt;/input&gt;\t\t ...\t\t methods:&#123;\t\t\t\t\t\tdoIt:function(p1,p2)&#123;&#125;&#125;\t\t 事件修饰符：(以下只有在按下回车才会触发)\t\t &lt;input type=&quot;text&quot; @keyup.enter=&quot;sayHi&quot;&gt;&lt;/input&gt;\t\t ...\t\t sayHi:function()&#123;&#125;4.v-show指令：根据表达式的真假，切换元素的显示和隐藏(本质是操作display属性)\t原理是修改元素的display来显示和隐藏组件，指令后面的内容最后都会解析为布尔值，如果为true，显示元素，值为false元素隐藏            &lt;img src=&quot;./assets/logo.png&quot; v-show=&quot;true&quot;/&gt;            &lt;img src=&quot;./assets/logo.png&quot; v-show=&quot;isShow&quot;/&gt;            &lt;img src=&quot;./assets/logo.png&quot; v-show=&quot;age &gt;= 18&quot;/&gt;5.v-if指令：根据表达式的真假，切换元素的显示和隐藏(本质是操作dom元素)            &lt;!-- v-if指令 --&gt;            &lt;button v-if=&quot;isShow&quot; &gt;v-if指令&lt;/button&gt;            &lt;button @click=&quot;toggleIsShow&quot;&gt;点击一下&lt;/button&gt;！！！！注意！！！！v-if和v-show的区别在：v-show只是在对组件的display属性进行变换，display=none但是组件仍然是存在的，但是v-if是对dom文档树进行的操作，如果为false则这个组件就不会创建6.v-bind指令：设置元素的属性(比如src,title,class等)\t\tv-bind:属性名=表达式\t\t\t\t\t&lt;!-- v-bind指令 --&gt;            &lt;!-- v-bind:属性名=表达式 --&gt;            &lt;div style=&quot;border:2px red solid;&quot;&gt;&lt;/div&gt;            &lt;div&gt;                &lt;img v-bind:src=&quot;imgSrc&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;&lt;br&gt;                &lt;img :src=&quot;imgSrc&quot; alt=&quot;&quot; :title=&quot;imgTitle + &#x27;&#x27;&quot; :class=&quot;isActive?&#x27;active&#x27;:&#x27;&#x27;&quot; @click=&quot;toggleActive&quot;/&gt;&lt;/br&gt;                &lt;img :src=&quot;imgSrc&quot; alt=&quot;&quot; :title=&quot;imgTitle + &#x27;&#x27;&quot; :class=&quot;&#123;active:isActive&#125;&quot; @click=&quot;toggleActive&quot;/&gt;            &lt;/div&gt;7:v-for指令:根据数据生成列表结构\t\t\t\t\t&lt;div&gt;                &lt;ul&gt;                    &lt;li v-for=&quot;item in imgArr&quot; :title=&quot;item&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;                &lt;/ul&gt;            &lt;/div&gt;\n\n图片切换demo\n&lt;div&gt;                &lt;img :src=&quot;imgArr[index]&quot; alt=&quot;&quot;&gt;                &lt;!-- 左箭头 --&gt;                &lt;a v-show=&quot;index!=0&quot; v-show=&quot;index!=0&quot; @click=&quot;prev&quot; class=&quot;left&quot;&gt;                    上一张                &lt;/a&gt;                &lt;!-- 右箭头 --&gt;                &lt;a v-show=&quot;index &lt; imgArr.length-1&quot; @click=&quot;next&quot; class=&quot;right&quot;&gt;                    下一张                &lt;/a&gt;            &lt;/div&gt; imgArr:[                        &quot;../src/assets/imgs/1.jpg&quot;,                        &quot;../src/assets/imgs/2.jpg&quot;,                        &quot;../src/assets/imgs/3.jpg&quot;,                        &quot;../src/assets/imgs/4.jpg&quot;,                        &quot;../src/assets/imgs/5.jpg&quot;,                    ],                    index:0,prev:function()&#123;                        this.index--;                    &#125;,                    next:function()&#123;                        this.index++;                    &#125;v-model指令：获取和设置表单元素的值(数据的双向绑定)\t\t\t\t\t\t &lt;div&gt;                &lt;input type=&quot; text&quot; v-model=&quot;message&quot;&gt;                &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt;            &lt;/div&gt;\t\t\t\t\t...\t\t\t\t\tdata:&#123;\t\t\t\t\t\t\tmessage: 哈哈哈,&#125;\n\n记事本应用\nvue-axios使用a:使用方法1：导入axios库&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;2：get请求方式axios.get(&quot;地址？key=value &amp; key2=value2&quot;).then(function(response)&#123;&#125;,function(err)&#123;&#125;)这里的地址就是文档提供的接口地址,第一个回调函数会在响应完成的时候触发，第二个回调函数会在请求失败的时候触发，形参可以用来获取信息，前者获取服务器响应的内容后者是响应失败的信息。地址后是需要传递的参数，key是文档提供的，value是具体传输的数据3:post请求方式axios.post(地址，&#123;key：value，key2：value2&#125;).then(function(response)&#123;&#125;,function(err)&#123;&#125;)与get请求不同的是，数据是以对象的形式传递注意：axios回调函数中的this已经改变，无法访问到vue实例中的数据，可以把this保存起来，回调函数中直接使用保存的this即可，和本地应用最大的区别就是改变了数据来源\n\n\n\n\n\n\n\n\n\nCSS定位方式1.因为绝对定位是根据最近一个定位了的元素进行的，所以采用相对定位和绝对定位结合的方式可以实现移动元素位置并且不占用位置。2.浮动定位：浮动的框可以向左或者向右移动，直到它的边缘碰到包含框或者另外一个浮动框的边框为止。3.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n业务流程(以上传用户照片为例)：  用户在客户端上传数据，经过校验，存储等过程之后，返回消息“上传成功”。  1.新建pojo类，对应数据库中应存放的照片大小，二进制内容等文件  2.Dao层，处理数据库数据，数据处理层  3.service层，实际功能，业务代码，  \n\n"},{"title":"正儿八斤写博客！设计模式","url":"/2021/12/02/%E6%AD%A3%E5%84%BF%E5%85%AB%E6%96%A4%E5%86%99%E5%8D%9A%E5%AE%A2%EF%BC%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","content":""},{"title":"终于！！！","url":"/2021/12/01/%E7%BB%88%E4%BA%8E%EF%BC%81%EF%BC%81%EF%BC%81/","content":"终于！！！！！！！！家人们，把公屏打在泪目上！！！！"}]
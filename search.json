[{"title":"Vue","url":"/2021/12/01/Vue/","content":"Vue语法//导入vue.js &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt;//使用vue指令必须导入命名空间v-bind=&quot;http://www.w3.org/1999/xhtml\n\n基础指令合集v-bind、v-if、v-else、v-for&lt;!--vue层  模板--&gt;&lt;div id=&quot;app&quot;&gt;&lt;!--    v-bind指令  用于将标签的某个属性和vue对象的某个属性绑定--&gt;    &lt;span v-bind:title=&quot;message&quot;&gt;&lt;!--            v-if指令，v-else指令--&gt;        &lt;h1 v-if=&quot;ok===true&quot;&gt;Yes&lt;/h1&gt;        &lt;h1 v-else&gt;No&lt;/h1&gt;    &lt;/span&gt;&lt;!--    v-for指令--&gt;    &lt;li v-for=&quot;item in items&quot;&gt;        &#123;&#123;item.messages&#125;&#125;    &lt;/li&gt;&lt;/div&gt;&lt;div id = &quot;func&quot;&gt;    &lt;button v-on:click=&quot;sayHi&quot;&gt;点击事件测试&lt;/button&gt;&lt;/div&gt;&lt;body&gt;&lt;script&gt;    // 创建vue对象    var vm = new Vue(&#123;         el:&quot;#app&quot;,//el即组件        // model 数据        data:&#123;            message:&quot;hello,vue!&quot;,            ok:true,            items:[                &#123;messages:&#x27;java&#x27; &#125;,                &#123;messages:&#x27;vue&#x27;&#125;,                &#123;messagea:&#x27;html&#x27; &#125;            ]        &#125;    &#125;);    var vs = new Vue(&#123;        el:func,        date:&#123;            message:&quot;vue方法绑定&quot;        &#125;,        methods:&#123;            //这里的事件必须在vue的对象中定义            sayHi:function () &#123;                alert(this.message);            &#125;        &#125;    &#125;)&lt;/script&gt;\n\n组件即可复用的Vue实例，就是一组可以重复使用的模板，跟JSTL的自定义标签，Thymeleaf的th:fragment等框架类似。\n//定义一个vue组件Vue.component(&quot;component_Name&quot;,&#123;  template:&quot;一段html模板&quot;&#125;);\n\n实例代码：\n&lt;body&gt;&lt;div id = &quot;app&quot;&gt;    &lt;wangxu&gt;&lt;/wangxu&gt;&lt;/div&gt;//组件中如果想接收外部传递的数据必须使用props属性来接收,并且也无法直接从其他组件或者vue对象中获取数据，需要通过中间件来动态绑定数据，即此处的  v-bind:dat=&quot;item&quot;&lt;div id = &quot;app2&quot;&gt;    &lt;vslist v-for=&quot;item in items&quot; v-bind:dat=&quot;item&quot;&gt;&lt;/vslist&gt;&lt;/div&gt;&lt;script&gt;    //定义一个Vue的组件Component    Vue.component(&quot;wangxu&quot;,&#123;        template:&#x27;&lt;div&gt;&lt;li&gt;ahahahah&lt;/li&gt;&#x27; +            &#x27;&lt;li&gt;sssss&lt;/li&gt;&lt;/div&gt;&#x27;    &#125;);    var vm = new Vue(&#123;        el:&quot;#app&quot;    &#125;);    Vue.component(&quot;vslist&quot;,&#123;        props:[&#x27;dat&#x27;],        template:&#x27;&lt;li&gt;&#123;&#123;dat&#125;&#125;&lt;/li&gt;&#x27;    &#125;)    var vm2 = new Vue(&#123;        el:&quot;#app2&quot;,        data:&#123;            items:[&#x27;java&#x27;,&#x27;linux&#x27;,&#x27;web&#x27;]        &#125;    &#125;)&lt;/script&gt;&lt;/body&gt;\n\nAxiosaxios是一个开源的可以用在浏览器端和NodeJS的异步通信框架，主要作用就是实现AJAX异步通信，功能特点如下：\n\n从浏览器中创建XMLHttpRequests\n从node.js创建http请求\n支持JS中链式变成\n拦截请求和响应\n转换请求数据和响应数据\n取消请求\n自动转换json数据\n客户端支持防御跨站请求伪造\n\n&lt;body&gt;&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt;&lt;div id = &quot;vue&quot; v-clock&gt;    &lt;div&gt;&#123;&#123;info.name&#125;&#125;&lt;/div&gt;    &lt;div&gt;&#123;&#123;info.address.city&#125;&#125;&lt;/div&gt;    &lt;a v-bind:href=&quot;info.url&quot;&gt;点击跳转&lt;/a&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var vm = new Vue(&#123;        el:&#x27;#vue&#x27;,        data()&#123;            //data()方法通过return来接收mounted（）返回的数据              return&#123;                  //请求的返回参数格式必须和json字符串一样                  info:&#123;                      name:null,                      address:&#123;                          city:null,                          country:null                      &#125;,                      url:null                  &#125;              &#125;        &#125;,        //Vue专注于视图层，数据交互叫交付于axios        mounted()&#123;//钩子函数 链式编程 ES6新特性            axios.get(&#x27;data.json&#x27;).then(response=&gt;(console.log(this.info=response.data)));        &#125;    &#125;);&lt;/script&gt;&lt;/body&gt;\n\n计算属性//在调用方法时，每次都需要进行计算，但是计算过程会有系统开销，如果这个这个计算结果不是经常变化的，就可以考虑把结果缓存起来，采用计算属性可以很方便的做到这一点，计算属性的主要特性就是为了将不经常变化的计算结果进行缓存以节约系统开销。&lt;body&gt;&lt;div id = &quot;app&quot;&gt;    &lt;p&gt;current_time&#123;&#123;current_time()&#125;&#125;&lt;/p&gt;    &lt;p&gt;current_time2&#123;&#123;current_time2&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt;    var vm = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            message:&quot;hello,wangxu&quot;        &#125;,        methods:&#123;            current_time:function()&#123;                return Date.now();//返回一个时间戳            &#125;        &#125;,        computed:&#123;//计算属性,类似于mybatis中缓存的概念，这里是虚拟dom，一但计算属性中涉及到数据更改，就立刻刷新dom重新计算            current_time2:function()&#123;                this.message;                return Date.now();            &#125;        &#125;    &#125;)&lt;/script&gt;\n\n内容分发使用这一种方式混合父组件与子组件自己的模板，这个过程被称为“内容分发”，在子组件中使用的特殊的元素作为容器的插槽\n&lt;body&gt;&lt;div id = &quot;app&quot;&gt;    &lt;todo&gt;        &lt;todo-title slot=&quot;todo-title&quot; v-bind:title = &quot;title&quot;&gt;&lt;/todo-title&gt;        &lt;todo-items slot=&quot;todo-items&quot; v-for=&quot;item in todoItems&quot; :item = &quot;item&quot;&gt;&lt;/todo-items&gt;    &lt;/todo&gt;&lt;/div&gt;&lt;!--即不是用插槽是以下样式--&gt;&lt;!--&lt;div&gt;--&gt;&lt;!--    &lt;title&gt;&lt;/title&gt;--&gt;&lt;!--    &lt;ul&gt;--&gt;&lt;!--        &lt;li&gt;java&lt;/li&gt;--&gt;&lt;!--        &lt;li&gt;linux&lt;/li&gt;--&gt;、&lt;!--        &lt;li&gt;web&lt;/li&gt;--&gt;&lt;!--    &lt;/ul&gt;--&gt;&lt;!--&lt;/div&gt;--&gt;&lt;script&gt;    //slot插槽    Vue.component(&quot;todo&quot;,&#123;        template:&#x27;&lt;div&gt;\\                        &lt;slot name=&quot;todo-title&quot;&gt;&lt;/slot&gt;\\                        &lt;ul&gt;\\                        &lt;slot name=&quot;todo-items&quot;&gt;&lt;/slot&gt;\\                        &lt;/ul&gt;\\                        &lt;/div&gt;&#x27;    &#125;);    Vue.component(&quot;todo-title&quot;,&#123;        props: [&#x27;title&#x27;],        template:&#x27;&lt;div&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;&#x27;    &#125;);    Vue.component(&quot;todo-items&quot;,&#123;        props: [&#x27;item&#x27;],        template:&#x27;&lt;li&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;&#x27;    &#125;);    var vm = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            title:&quot;啦啦啦德玛西亚&quot;,            todoItems:[&#x27;java&#x27;,&#x27;Linux&#x27;,&#x27;web&#x27;]        &#125;    &#125;)&lt;/script&gt;&lt;/body&gt;\n\n\n自定义内容分发&lt;body&gt;&lt;!--view层模板--&gt;&lt;div id = &quot;app&quot;&gt;    &lt;todo&gt;        &lt;todo-title slot = &quot;todo-title&quot; title = &quot;title&quot;&gt;&lt;/todo-title&gt;        &lt;todo-items slot = &quot;todo-items&quot; v-for=&quot;(item,index) in todoitems&quot; v-bind:item=&quot;item&quot; v-bind:index=&quot;index&quot; v-on:r=&quot;removeitems(index)&quot;&gt;&lt;/todo-items&gt;    &lt;/todo&gt;&lt;/div&gt;&lt;script&gt;    // slot插槽    Vue.component(&quot;todo&quot;,&#123;        template:&#x27;&lt;div&gt;\\                        &lt;slot name=&quot;todo-title&quot;&gt;&lt;/slot&gt;\\                        &lt;ul&gt;\\                        &lt;slot name=&quot;todo-items&quot;&gt;&lt;/slot&gt;\\                        &lt;/ul&gt;\\                        &lt;/div&gt;&#x27;    &#125;);    Vue.component(&quot;todo-title&quot;,&#123;        props:[&#x27;title&#x27;],        template:&#x27;&lt;div&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;&#x27;    &#125;);    Vue.component(&quot;todo-items&quot;,&#123;        props: [&#x27;item&#x27;,&#x27;index&#x27;],        //组件里只能绑定到当前组件中的方法        template:&#x27;&lt;li&gt;&#123;&#123;index&#125;&#125;----&#123;&#123;item&#125;&#125;&lt;button @click=&quot;remove&quot;&gt;删除&lt;/button&gt;&lt;/li&gt;&#x27;,        methods:&#123;            remove:function(index)&#123;                this.$emit(&#x27;r&#x27;,index);            &#125;,            add:function(index)&#123;                alert(&quot;hahahahah&quot; + index);            &#125;        &#125;    &#125;);    var vm = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            title:&quot;干死vue啊&quot;,            todoitems:[&#x27;java&#x27;,&#x27;linux&#x27;,&#x27;web&#x27;]        &#125;,        methods:&#123;            removeitems:function(index)&#123;                console.log(&quot;删除了&quot; + this.todoitems[index]);                this.todoitems.splice(index,1);//一次删除一个元素            &#125;        &#125;    &#125;);&lt;/script&gt;&lt;/body&gt;\n\n\n使用Vue-Cli开发1.安装Node.js\n2.配置node.js环境变量\n3.安装node.js镜像加速器\nnpm install --registry=https://registry.npm.taobao.org或者&lt;!--    全局安装--&gt;npm install cnpm -g \n\n4.安装vue-cli\ncnpm install vue-cli -g\n\n5.创建vue项目\nVue init webpack projectName\n\n6.初始化\n进入项目目录，并执行  npm install命令\n\n7.启动web项目\n进入项目目录，并执行   npm run dev命令 \n\n\n\n安装webpacknpm intsall webpack -gnpm install webpack-cli -g测试：webpack -vwebpack-cli -v\n\nwebpack配置创建webpack.config.js配置文件  entry：入口文件，指定webpack用哪个文件作为项目的入口  output:输出，指定webpack把处理完成的文件放置到指定路径  module:模块，由于处理各种类型的文件  plugins:插件，如：热更新，代码重用等  resolve：设置路径指向  watch:监听，用于设置文件改动后直接打包\n\n使用webpack\n\n安装Vue-routernpm install vue-router --save-dev\n\n\n\n\n\n\n\n\n\n\n\n\n\n流程\n1.新建vue组件a.vue2.在app.vue中导入相应的组件a,并且在相应的comments中添加a3.配置路由，import想要使用路由的组件，并在routes的component属性中配置路由\n\n\n\n\n\n\n\n注意事项：el挂载点：\t1.Vue实例会管理el选项命中的元素以及其内部的后代元素\t2.可以使用非id选择器，但是建议使用id选择器\t3.可以使用奇特的双标签设置dom元素，但不能使用HTML和BODYel挂载点的作用：\t设置vue实例管理的元素，在html中&#123;&#123;&#125;&#125;中的元素就会被data中too同名的数据替换data：数据对象\t1.vue中用到的数据定义在data中\t2.data中可以使用复杂类型的数据\t3.渲染复杂数据类型时遵守js语法即可VUe指令合集1.v-text指令：设置标签的文本值(textContent)    &lt;!-- 这个是全部替换数据 --&gt;    &lt;h3 v-text=&quot;message + &#x27;!!!&#x27;&quot;&gt;哈哈哈&lt;/h3&gt;    &lt;!-- 替换部分数据 --&gt;    &lt;h3&gt;哈哈哈&#123;&#123;message&#125;&#125;&lt;/h3&gt;2.v-html指令：设置元素的innerHTML，data中有html结构的书会被解析为\t\t\t\t\t\t\t标签\t\t&lt;!-- 这个指令会解析message中的标签并渲染出来 --&gt;     &lt;p v-html=&quot;content&quot;&gt;&lt;/p&gt;3.v-on指令：为元素绑定事件,事件名不需要写on，指令可以简写为@，绑定的方法定义在methods属性中\t\t&lt;!-- v-on：为元素绑定事件 --&gt;    &lt;input type=&quot;button&quot; value=&quot;事件绑定&quot; v-on:事件类型=&quot;方法&quot;/&gt;\t\t&lt;!-- v-on：为元素绑定事件 ,并且v-on：可以替换成@ --&gt;    &lt;input type=&quot;button&quot; value=&quot;事件绑定&quot; v-on:click=&quot;doIt&quot;/&gt;补充：传递自定义参数，事件修饰符\t\t 传递参数：\t\t &lt;input type=&quot;button&quot; @click=&quot;doIt(p1,p2)&quot;&gt;&lt;/input&gt;\t\t ...\t\t methods:&#123;\t\t\t\t\t\tdoIt:function(p1,p2)&#123;&#125;&#125;\t\t 事件修饰符：(以下只有在按下回车才会触发)\t\t &lt;input type=&quot;text&quot; @keyup.enter=&quot;sayHi&quot;&gt;&lt;/input&gt;\t\t ...\t\t sayHi:function()&#123;&#125;4.v-show指令：根据表达式的真假，切换元素的显示和隐藏(本质是操作display属性)\t原理是修改元素的display来显示和隐藏组件，指令后面的内容最后都会解析为布尔值，如果为true，显示元素，值为false元素隐藏            &lt;img src=&quot;./assets/logo.png&quot; v-show=&quot;true&quot;/&gt;            &lt;img src=&quot;./assets/logo.png&quot; v-show=&quot;isShow&quot;/&gt;            &lt;img src=&quot;./assets/logo.png&quot; v-show=&quot;age &gt;= 18&quot;/&gt;5.v-if指令：根据表达式的真假，切换元素的显示和隐藏(本质是操作dom元素)            &lt;!-- v-if指令 --&gt;            &lt;button v-if=&quot;isShow&quot; &gt;v-if指令&lt;/button&gt;            &lt;button @click=&quot;toggleIsShow&quot;&gt;点击一下&lt;/button&gt;！！！！注意！！！！v-if和v-show的区别在：v-show只是在对组件的display属性进行变换，display=none但是组件仍然是存在的，但是v-if是对dom文档树进行的操作，如果为false则这个组件就不会创建6.v-bind指令：设置元素的属性(比如src,title,class等)\t\tv-bind:属性名=表达式\t\t\t\t\t&lt;!-- v-bind指令 --&gt;            &lt;!-- v-bind:属性名=表达式 --&gt;            &lt;div style=&quot;border:2px red solid;&quot;&gt;&lt;/div&gt;            &lt;div&gt;                &lt;img v-bind:src=&quot;imgSrc&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;&lt;br&gt;                &lt;img :src=&quot;imgSrc&quot; alt=&quot;&quot; :title=&quot;imgTitle + &#x27;&#x27;&quot; :class=&quot;isActive?&#x27;active&#x27;:&#x27;&#x27;&quot; @click=&quot;toggleActive&quot;/&gt;&lt;/br&gt;                &lt;img :src=&quot;imgSrc&quot; alt=&quot;&quot; :title=&quot;imgTitle + &#x27;&#x27;&quot; :class=&quot;&#123;active:isActive&#125;&quot; @click=&quot;toggleActive&quot;/&gt;            &lt;/div&gt;7:v-for指令:根据数据生成列表结构\t\t\t\t\t&lt;div&gt;                &lt;ul&gt;                    &lt;li v-for=&quot;item in imgArr&quot; :title=&quot;item&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;                &lt;/ul&gt;            &lt;/div&gt;\n\n图片切换demo\n&lt;div&gt;                &lt;img :src=&quot;imgArr[index]&quot; alt=&quot;&quot;&gt;                &lt;!-- 左箭头 --&gt;                &lt;a v-show=&quot;index!=0&quot; v-show=&quot;index!=0&quot; @click=&quot;prev&quot; class=&quot;left&quot;&gt;                    上一张                &lt;/a&gt;                &lt;!-- 右箭头 --&gt;                &lt;a v-show=&quot;index &lt; imgArr.length-1&quot; @click=&quot;next&quot; class=&quot;right&quot;&gt;                    下一张                &lt;/a&gt;            &lt;/div&gt; imgArr:[                        &quot;../src/assets/imgs/1.jpg&quot;,                        &quot;../src/assets/imgs/2.jpg&quot;,                        &quot;../src/assets/imgs/3.jpg&quot;,                        &quot;../src/assets/imgs/4.jpg&quot;,                        &quot;../src/assets/imgs/5.jpg&quot;,                    ],                    index:0,prev:function()&#123;                        this.index--;                    &#125;,                    next:function()&#123;                        this.index++;                    &#125;v-model指令：获取和设置表单元素的值(数据的双向绑定)\t\t\t\t\t\t &lt;div&gt;                &lt;input type=&quot; text&quot; v-model=&quot;message&quot;&gt;                &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt;            &lt;/div&gt;\t\t\t\t\t...\t\t\t\t\tdata:&#123;\t\t\t\t\t\t\tmessage: 哈哈哈,&#125;\n\n记事本应用\nvue-axios使用a:使用方法1：导入axios库&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;2：get请求方式axios.get(&quot;地址？key=value &amp; key2=value2&quot;).then(function(response)&#123;&#125;,function(err)&#123;&#125;)这里的地址就是文档提供的接口地址,第一个回调函数会在响应完成的时候触发，第二个回调函数会在请求失败的时候触发，形参可以用来获取信息，前者获取服务器响应的内容后者是响应失败的信息。地址后是需要传递的参数，key是文档提供的，value是具体传输的数据3:post请求方式axios.post(地址，&#123;key：value，key2：value2&#125;).then(function(response)&#123;&#125;,function(err)&#123;&#125;)与get请求不同的是，数据是以对象的形式传递注意：axios回调函数中的this已经改变，无法访问到vue实例中的数据，可以把this保存起来，回调函数中直接使用保存的this即可，和本地应用最大的区别就是改变了数据来源\n\n\n\n\n\n\n\n\n\nCSS定位方式1.因为绝对定位是根据最近一个定位了的元素进行的，所以采用相对定位和绝对定位结合的方式可以实现移动元素位置并且不占用位置。2.浮动定位：浮动的框可以向左或者向右移动，直到它的边缘碰到包含框或者另外一个浮动框的边框为止。3.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n业务流程(以上传用户照片为例)：  用户在客户端上传数据，经过校验，存储等过程之后，返回消息“上传成功”。  1.新建pojo类，对应数据库中应存放的照片大小，二进制内容等文件  2.Dao层，处理数据库数据，数据处理层  3.service层，实际功能，业务代码，  \n\n"},{"title":"终于！！！","url":"/2021/12/01/%E7%BB%88%E4%BA%8E%EF%BC%81%EF%BC%81%EF%BC%81/","content":"终于！！！！！！！！家人们，把公屏打在泪目上！！！！"},{"title":"正儿八斤写博客！设计模式","url":"/2021/12/02/%E6%AD%A3%E5%84%BF%E5%85%AB%E6%96%A4%E5%86%99%E5%8D%9A%E5%AE%A2%EF%BC%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","content":"1\n\n"}]